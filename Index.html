<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>NAMS Restroom Sign-Out</title>
    <!-- Import Material Icons (keeping just the icons) -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <style>
      /* Reset and base styles */
      * {
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        line-height: 1.5;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        margin: -10px;
      }

      .col {
        padding: 10px;
      }

      .col.s8 {
        flex: 0 0 66.666%;
      }

      .col.s4 {
        flex: 0 0 33.333%;
      }

      .col.s12 {
        flex: 0 0 100%;
      }

      /* Card styles */
      .card-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 15px;
      }

      .teal.lighten-4 {
        background-color: #b2dfdb !important;
      }

      /* Button styles */
      .btn {
        display: inline-block;
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        text-decoration: none;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      .btn:hover:not(.disabled):not(.currently-out):not(.waiting):not(
          .already-went
        ) {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      /* Form styles */
      select.browser-default {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 14px;
      }

      /* Table styles */
      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      table.striped tbody tr:nth-child(even) {
        background-color: #f9f9f9;
      }

      th,
      td {
        padding: 12px 8px;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
      }

      th {
        background-color: #f5f5f5;
        font-weight: 600;
        text-align: center !important;
      }

      /* Modern Spinner CSS Custom Properties */
      :root {
        --spinner-primary-color: #2196f3;
        --spinner-secondary-color: rgba(33, 150, 243, 0.3);
        --spinner-size: 12px;
        --spinner-spacing: 8px;
        --spinner-duration: 1.2s;
      }

      /* Modern Pulsing Dots Spinner */
      .modern-spinner {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spinner-spacing);
      }

      .modern-spinner .dot {
        width: var(--spinner-size);
        height: var(--spinner-size);
        background-color: var(--spinner-primary-color);
        border-radius: 50%;
        animation: pulse-dot var(--spinner-duration) ease-in-out infinite;
        will-change: transform, opacity;
      }

      .modern-spinner .dot:nth-child(1) {
        animation-delay: 0s;
      }

      .modern-spinner .dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .modern-spinner .dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      /* Pulsing Animation Keyframes */
      @keyframes pulse-dot {
        0%,
        100% {
          transform: scale(0.8);
          opacity: 0.3;
        }
        50% {
          transform: scale(1.2);
          opacity: 1;
        }
      }

      .highlight {
        background-color: #ffff99;
        /* light yellow highlight */
      }

      .hold-text {
        color: red;
      }

      .out-btn {
        background-color: #1976d2;
        /* blue instead of amber */
        color: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .out-btn.disabled {
        background-color: #9e9e9e !important;
        /* grey when disabled */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.6;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .out-btn.waiting {
        background-color: #424242 !important;
        /* darker grey for WAITING */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.8;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .out-btn.already-went {
        background-color: #757575 !important;
        /* grey for ALREADY WENT */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.6;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Enhanced button states for new behavior */
      .out-btn.currently-out {
        background-color: #ffc107 !important;
        /* yellow for CURRENTLY OUT */
        color: #000000 !important;
        /* black text for better contrast on yellow */
        pointer-events: none;
        opacity: 1;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .out-btn.rr-available {
        background-color: #4caf50 !important;
        /* green for RR AVAILABLE */
        color: #ffffff !important;
        pointer-events: auto;
        opacity: 1;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .out-btn.rr-available:hover {
        background-color: #45a049 !important;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
      }

      .back-btn {
        background-color: #43a047;
        /* green */
        color: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .back-btn.active {
        background-color: #d32f2f !important;
        /* red when student is out and needs to come back */
        color: white !important;
      }

      .back-btn.disabled {
        background-color: #9e9e9e !important;
        /* grey when disabled */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.6;
      }

      .back-btn.already-went {
        background-color: #757575 !important;
        /* grey for ALREADY WENT */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.6;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Enhanced button state transitions and animations */
      .out-btn,
      .back-btn {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: background-color, color, transform, box-shadow, opacity;
      }

      /* Smooth color transitions for all button states */
      .out-btn:not(.disabled):not(.currently-out):not(.waiting):not(
          .already-went
        ):hover {
        background-color: #1565c0 !important;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(25, 118, 210, 0.3);
      }

      /* Focus states for accessibility */
      .btn:focus {
        outline: 2px solid #2196f3;
        outline-offset: 2px;
      }

      .out-btn.currently-out:focus,
      .out-btn.waiting:focus,
      .out-btn.disabled:focus,
      .out-btn.already-went:focus {
        outline: none; /* Remove focus outline for non-interactive states */
      }

      /* Animation for button state changes */
      @keyframes buttonStateChange {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .btn.state-changing {
        animation: buttonStateChange 0.3s ease-in-out;
      }

      /* Back button visibility states */
      .back-btn.hidden {
        visibility: hidden;
        opacity: 0;
        transition:
          visibility 0s 0.3s,
          opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        transform: scale(0.95);
      }

      .back-btn.visible {
        visibility: visible;
        opacity: 1;
        transition:
          visibility 0s,
          opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
          transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        transform: scale(1);
      }

      /* Enhanced Back button active state */
      .back-btn.active:hover {
        background-color: #c62828 !important;
        transform: translateY(-1px) scale(1);
        box-shadow: 0 4px 8px rgba(211, 47, 47, 0.3);
      }

      .table-container {
        overflow-x: auto;
        overflow-y: auto;
        max-height: 70vh;
        padding: 15px !important;
        background-color: #f8f9fa !important;
        margin-bottom: 10px !important;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
      }



      /* Regular header styles with tight spacing (no longer sticky) */
      .sticky-header {
        background-color: white;
        padding: 10px 0;
        border-bottom: 2px solid #e0e0e0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        line-height: 1.2;
      }

      .sticky-header h4,
      .sticky-header h5,
      .sticky-header h6 {
        margin: 0 0 5px 0;
        line-height: 1.2;
      }

      .sticky-header small {
        margin-bottom: 5px !important;
      }

      /* Loading state styles */
      .loading-blur {
        filter: blur(1px);
        opacity: 0.5;
        pointer-events: none;
      }

      .loading-overlay {
        border-radius: 4px;
      }

      /* Center table headers */
      th {
        text-align: center !important;
      }

      /* Clean table headers */
      .table-container thead th {
        background: #f5f5f5;
        font-weight: 600;
      }


    </style>
  </head>

  <body>
    <div class="container" x-data="appData()" x-init="init()" @click.away="hideSearchResults()">
      <!-- Sticky header with date, period, and teacher info -->
      <div class="sticky-header">
        <h1>Northside Alternative MS</h1>
        <H3>Student Restroom Log</H3>
        <h5 x-text="dateString"></h5>
        <h5 x-text="'Current Period: ' + periodString"></h5>
        <small
          x-text="nextPeriodString"
          style="
            color: #292f60;
            font-style: italic;
            display: block;
            margin-bottom: 5px;
          "
        ></small>

        <!-- Auto-detected teacher info -->
        <div class="row" x-show="detectedTeacher">
          <div class="col s12">
            <div class="card-panel teal lighten-4" style="padding: 10px">
              <span class="black-text">
                <i
                  class="material-icons tiny"
                  style="vertical-align: text-bottom"
                  >person</i
                >
                Hello, <strong x-text="detectedTeacher"></strong>
                <small x-show="userEmail"
                  >(logged in as: <span x-text="userEmail"></span>)</small
                >
              </span>
            </div>
          </div>
        </div>
      </div>

      <!-- Refresh controls -->
      <div class="row" style="margin-bottom: 10px">
        <div class="col s12">
          <div class="card-panel" style="padding: 10px">
            <button
              class="btn"
              @click="manualRefresh()"
              style="margin-right: 10px"
            >
              <i class="material-icons left">refresh</i>Refresh Data
            </button>
          </div>
        </div>
      </div>

      <!-- Student Search Section -->
      <div class="row">
        <div class="col s12">
          <div class="card-panel" style="padding: 15px">
            <h5 style="margin-top: 0">ADD STUDENT</h5>
            
            <!-- Search Input -->
            <div style="position: relative; margin-bottom: 15px">
              <input 
                type="text" 
                x-model="searchTerm"
                @input="filterStudents()"
                @focus="showAllStudents()"
                @keydown.escape="hideSearchResults()"
                @keydown.arrow-down.prevent="highlightNext()"
                @keydown.arrow-up.prevent="highlightPrevious()"
                @keydown.enter.prevent="selectHighlighted()"
                placeholder="Click to see all students or type to search..."
                style="
                  width: 100%; 
                  padding: 12px; 
                  border: 2px solid #ddd; 
                  border-radius: 4px; 
                  font-size: 16px;
                  box-sizing: border-box;
                "
              />
              
              <!-- Search Results Dropdown -->
              <div 
                x-show="showSearchResults && (searchResults.length > 0 || isSearching)"
                style="
                  position: absolute;
                  top: 100%;
                  left: 0;
                  right: 0;
                  background: white;
                  border: 1px solid #ddd;
                  border-top: none;
                  border-radius: 0 0 4px 4px;
                  max-height: 300px;
                  overflow-y: auto;
                  z-index: 1000;
                  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                "
              >
                <!-- Loading state -->
                <div x-show="isSearching" style="padding: 15px; text-align: center; color: #666;">
                  <div class="modern-spinner" style="justify-content: center; margin-bottom: 8px;">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                  </div>
                  Loading students...
                </div>

                <!-- Results count header -->
                <div x-show="!isSearching && searchResults.length > 0" 
                     style="
                       padding: 8px 12px; 
                       background: #f8f9fa; 
                       border-bottom: 1px solid #e9ecef; 
                       font-size: 12px; 
                       color: #666;
                       font-weight: 500;
                     ">
                  <span x-show="!searchTerm || searchTerm.trim() === ''" x-text="`All Students (${searchResults.length})`"></span>
                  <span x-show="searchTerm && searchTerm.trim() !== ''" x-text="`${searchResults.length} students found`"></span>
                </div>

                <!-- Student list -->
                <template x-for="(student, index) in searchResults" :key="student.name">
                  <div 
                    @click="selectStudent(student)"
                    @mouseenter="highlightedIndex = index"
                    :class="{ 'highlighted': index === highlightedIndex }"
                    style="
                      padding: 12px;
                      cursor: pointer;
                      border-bottom: 1px solid #f0f0f0;
                      transition: background-color 0.2s ease;
                    "
                    :style="{ 
                      'background-color': index === highlightedIndex ? '#e3f2fd' : 'white',
                      'border-left': index === highlightedIndex ? '3px solid #2196f3' : '3px solid transparent'
                    }"
                  >
                    <div style="font-weight: 500; color: #333;" x-text="student.name"></div>
                    <div x-show="student.id" style="font-size: 12px; color: #666; margin-top: 2px;">
                      ID: <span x-text="student.id"></span>
                    </div>
                  </div>
                </template>

                <!-- No results message -->
                <div x-show="!isSearching && searchResults.length === 0 && searchTerm && searchTerm.trim() !== ''" 
                     style="padding: 20px; text-align: center; color: #666; font-style: italic;">
                  No students found matching "<span x-text="searchTerm"></span>"
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Active Students Table -->
      <div class="row">
        <!-- Active Students table column -->
        <div class="col s12">
          <h5>RESTROOM LIST</h5>

          <div class="table-container" style="position: relative">
            <!-- Loading Spinner Overlay -->
            <div
              x-show="isLoading"
              class="loading-overlay"
              style="
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(255, 255, 255, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                z-index: 10;
                min-height: 200px;
              "
            >
              <div class="modern-spinner">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
              </div>
              <p style="margin-top: 15px; color: #666; font-weight: 500">
                <span
                  x-text="loadingMessage || 'Loading student data...'"
                ></span>
              </p>
            </div>

            <!-- No Active Students Message -->
            <div x-show="!isLoading && students.length === 0" style="text-align: center; padding: 40px; color: #666;">
              <i class="material-icons" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;">search</i>
              <h6>No Active Students</h6>
            </div>

            <!-- Active Students Table -->
            <table x-show="students.length > 0" class="striped" :class="{ 'loading-blur': isLoading }">
              <thead>
                <tr>
                  <th>Student Name</th>
                  <th>Gender</th>
                  <th>Teacher</th>
                  <th>Request Status</th>
                  <th>Out Time</th>
                  <th>Return Status</th>
                  <th>Back Time</th>
                  <th>Remove</th>
                </tr>
              </thead>
              <tbody>
                <template x-for="stu in students" :key="stu.name">
                  <tr :class="{ highlight: isReadyToMarkOut(stu) }">
                    <td x-text="stu.name"></td>
                    <td>
                      <select
                        x-model="stu.gender"
                        @change="onGenderChange(stu)"
                        class="browser-default"
                      >
                        <option value=""></option>
                        <option value="G">G</option>
                        <option value="B">B</option>
                      </select>
                    </td>
                    <td>
                      <select
                        x-model="stu.teacher"
                        @change="onTeacherChange(stu)"
                        class="browser-default"
                      >
                        <option value="">Select Teacher</option>
                        <template x-for="t in teachers" :key="t">
                          <option x-text="t" :value="t"></option>
                        </template>
                      </select>
                    </td>
                    <td>
                      <button
                        class="btn out-btn"
                        :class="getButtonClass(stu)"
                        @click="markOut(stu)"
                        :title="getButtonTitle(stu)"
                      >
                        <span x-text="getButtonText(stu)"></span>
                      </button>
                    </td>
                    <td>
                      <span
                        x-text="formatTime(stu.outTime || stu.holdNotice)"
                      ></span>
                    </td>
                    <td>
                      <button
                        class="btn back-btn"
                        :class="{ 
                          'hidden': !stu.outTime || stu.backTime,
                          'visible': stu.outTime && !stu.backTime,
                          'active': stu.outTime && !stu.backTime,
                          'already-went': stu.outTime && stu.backTime
                        }"
                        @click="markBack(stu)"
                        :title="getBackButtonTitle(stu)"
                      >
                        <span x-text="getBackButtonText(stu)"></span>
                      </button>
                    </td>
                    <td>
                      <span x-text="formatTime(stu.backTime)"></span>
                    </td>
                    <td>
                      <button
                        class="btn"
                        style="background-color: #f44336; color: white; padding: 4px 8px; font-size: 12px;"
                        @click="removeStudent(stu)"
                        title="Remove student from active management"
                      >
                        <i class="material-icons" style="font-size: 16px;">close</i>
                      </button>
                    </td>
                  </tr>
                </template>
              </tbody>
            </table>
          </div>
        </div>


      </div>
    </div>

    <script>
      /**
       * SmartPollingManager for adaptive refresh based on user activity
       * Adjusts polling frequency based on user interaction patterns
       */
      class SmartPollingManager {
        constructor() {
          this.isActive = false;
          this.currentInterval = null;
          this.isCheckingForUpdates = false; // Prevent concurrent update checks
          this.baseIntervalMs = 60000; // 1 minute base interval
          this.activeIntervalMs = 30000; // 30 seconds when active
          this.inactiveIntervalMs = 120000; // 2 minutes when inactive
          this.maxIntervalMs = 300000; // 5 minutes maximum

          this.lastUserActivity = Date.now();
          this.lastUpdateCheck = 0;
          this.lastUpdateTimestamp = 0;
          this.consecutiveNoChanges = 0;
          this.maxConsecutiveNoChanges = 5;

          this.activityThresholds = {
            active: 60000, // 1 minute since last activity = active
            inactive: 300000, // 5 minutes since last activity = inactive
            dormant: 900000, // 15 minutes since last activity = dormant
          };

          this.callbacks = {
            onUpdate: null,
            onActivityChange: null,
          };

          this.stats = {
            totalChecks: 0,
            updatesFound: 0,
            lastUpdateTime: null,
            averageInterval: this.baseIntervalMs,
          };
        }

        /**
         * Start adaptive polling with callbacks
         * @param {Function} updateCallback - Function to call when updates are needed
         * @param {Function} activityCallback - Function to call when activity level changes
         */
        startAdaptivePolling(updateCallback, activityCallback = null) {
          console.log("SmartPollingManager: Starting adaptive polling");

          this.callbacks.onUpdate = updateCallback;
          this.callbacks.onActivityChange = activityCallback;
          this.isActive = true;
          this.lastUserActivity = Date.now();

          // Start with base interval
          this._scheduleNextCheck(this.baseIntervalMs);

          // Set up activity monitoring
          this._setupActivityMonitoring();

          console.log(
            `SmartPollingManager: Started with ${this.baseIntervalMs}ms base interval`,
          );
        }

        /**
         * Stop adaptive polling
         */
        stopPolling() {
          console.log("SmartPollingManager: Stopping adaptive polling");

          if (this.currentInterval) {
            clearTimeout(this.currentInterval);
            this.currentInterval = null;
          }

          this.isActive = false;
          this.isCheckingForUpdates = false; // Clear any pending check flag
          this._cleanupActivityMonitoring();
        }

        /**
         * Record user activity to adjust polling frequency
         */
        recordUserActivity() {
          const now = Date.now();
          const wasActive = this._isUserActive();

          this.lastUserActivity = now;

          // Check if activity level changed
          const isNowActive = this._isUserActive();
          if (wasActive !== isNowActive && this.callbacks.onActivityChange) {
            this.callbacks.onActivityChange(
              isNowActive ? "active" : "inactive",
            );
          }

          // If we were in a long interval and user became active, reschedule sooner
          if (isNowActive && this.currentInterval) {
            const nextCheckIn = this._getOptimalInterval();
            if (nextCheckIn < this.activeIntervalMs) {
              console.log(
                "SmartPollingManager: User became active, rescheduling check sooner",
              );
              this._scheduleNextCheck(this.activeIntervalMs);
            }
          }
        }

        /**
         * Check for updates using incremental update endpoint
         * @param {number} lastUpdateTimestamp - Timestamp of last known update
         * @returns {Promise} - Promise that resolves with update info
         */
        async checkForUpdates(lastUpdateTimestamp = null) {
          if (!this.isActive) {
            console.log(
              "SmartPollingManager: Not active, skipping update check",
            );
            return null;
          }

          // Prevent concurrent update checks
          if (this.isCheckingForUpdates) {
            console.log(
              "SmartPollingManager: Update check already in progress, skipping",
            );
            return null;
          }

          this.isCheckingForUpdates = true;
          const now = Date.now();
          this.stats.totalChecks++;
          this.lastUpdateCheck = now;

          console.log(
            "SmartPollingManager: Checking for updates using optimized endpoint...",
          );

          return new Promise((resolve, reject) => {
            // Use the optimized incremental update endpoint
            if (
              typeof google !== "undefined" &&
              google.script &&
              google.script.run.api_getStatusUpdatesOptimized
            ) {
              // Simplified polling - just trigger a full refresh
              console.log("SmartPollingManager: Triggering full refresh (no incremental updates)");
              
              // Always trigger update callback for full refresh
              if (this.callbacks.onUpdate) {
                this.callbacks.onUpdate({
                  hasUpdates: true,
                  fallback: true,
                  fullRefresh: true
                });
              }

              // Schedule next check
              this._scheduleNextCheck();
              this.isCheckingForUpdates = false;
              resolve({
                hasUpdates: true,
                fallback: true,
                fullRefresh: true
              });
            } else {
              // Fallback: just trigger a regular update
              console.log(
                "SmartPollingManager: Optimized endpoint not available, using fallback update method",
              );
              if (this.callbacks.onUpdate) {
                this.callbacks.onUpdate({ hasUpdates: true, fallback: true });
              }
              this._scheduleNextCheck();
              this.isCheckingForUpdates = false; // Clear the flag
              resolve({ hasUpdates: true, fallback: true });
            }
          });
        }

        /**
         * Adjust polling frequency based on current conditions
         * @param {Object} options - Options for frequency adjustment
         */
        adjustPollingFrequency(options = {}) {
          const {
            forceActive = false,
            forceInactive = false,
            customInterval = null,
          } = options;

          let newInterval;

          if (customInterval) {
            newInterval = Math.max(customInterval, 10000); // Minimum 10 seconds
          } else if (forceActive) {
            newInterval = this.activeIntervalMs;
          } else if (forceInactive) {
            newInterval = this.inactiveIntervalMs;
          } else {
            newInterval = this._getOptimalInterval();
          }

          console.log(
            `SmartPollingManager: Adjusting frequency to ${newInterval}ms`,
          );

          // Update average interval for stats
          this.stats.averageInterval =
            (this.stats.averageInterval + newInterval) / 2;

          // Reschedule if currently active
          if (this.isActive && this.currentInterval) {
            this._scheduleNextCheck(newInterval);
          }
        }

        /**
         * Get current polling statistics
         * @returns {Object} - Polling statistics
         */
        getStats() {
          const now = Date.now();
          const activityLevel = this._getActivityLevel();
          const timeSinceLastActivity = now - this.lastUserActivity;
          const timeSinceLastCheck = now - this.lastUpdateCheck;

          return {
            isActive: this.isActive,
            activityLevel: activityLevel,
            timeSinceLastActivity: timeSinceLastActivity,
            timeSinceLastCheck: timeSinceLastCheck,
            totalChecks: this.stats.totalChecks,
            updatesFound: this.stats.updatesFound,
            updateRate:
              this.stats.totalChecks > 0
                ? (
                    (this.stats.updatesFound / this.stats.totalChecks) *
                    100
                  ).toFixed(1) + "%"
                : "0%",
            consecutiveNoChanges: this.consecutiveNoChanges,
            averageInterval: Math.round(this.stats.averageInterval),
            lastUpdateTime: this.stats.lastUpdateTime,
            nextCheckIn: this.currentInterval ? "scheduled" : "not scheduled",
          };
        }

        /**
         * Private method to determine optimal polling interval
         * @returns {number} - Optimal interval in milliseconds
         */
        _getOptimalInterval() {
          const activityLevel = this._getActivityLevel();
          let interval;

          switch (activityLevel) {
            case "active":
              interval = this.activeIntervalMs;
              break;
            case "inactive":
              interval = this.inactiveIntervalMs;
              break;
            case "dormant":
              interval = this.maxIntervalMs;
              break;
            default:
              interval = this.baseIntervalMs;
          }

          // Increase interval if we've had many consecutive no-change checks
          if (this.consecutiveNoChanges >= this.maxConsecutiveNoChanges) {
            interval = Math.min(interval * 2, this.maxIntervalMs);
            console.log(
              `SmartPollingManager: Increasing interval due to ${this.consecutiveNoChanges} consecutive no-change checks`,
            );
          }

          return interval;
        }

        /**
         * Private method to determine current activity level
         * @returns {string} - Activity level: 'active', 'inactive', or 'dormant'
         */
        _getActivityLevel() {
          const timeSinceActivity = Date.now() - this.lastUserActivity;

          if (timeSinceActivity < this.activityThresholds.active) {
            return "active";
          } else if (timeSinceActivity < this.activityThresholds.inactive) {
            return "inactive";
          } else {
            return "dormant";
          }
        }

        /**
         * Private method to check if user is currently active
         * @returns {boolean} - True if user is active
         */
        _isUserActive() {
          return this._getActivityLevel() === "active";
        }

        /**
         * Private method to schedule the next update check
         * @param {number} intervalMs - Interval in milliseconds (optional)
         */
        _scheduleNextCheck(intervalMs = null) {
          if (this.currentInterval) {
            clearTimeout(this.currentInterval);
          }

          const interval = intervalMs || this._getOptimalInterval();

          this.currentInterval = setTimeout(() => {
            if (this.isActive) {
              this.checkForUpdates();
            }
          }, interval);

          console.log(
            `SmartPollingManager: Next check scheduled in ${interval}ms (${Math.round(interval / 1000)}s)`,
          );
        }

        /**
         * Private method to set up activity monitoring
         */
        _setupActivityMonitoring() {
          // Monitor various user interaction events
          const events = [
            "click",
            "keydown",
            "mousemove",
            "scroll",
            "touchstart",
          ];

          this._activityHandler = () => {
            this.recordUserActivity();
          };

          // Throttle activity recording to avoid excessive calls
          this._throttledActivityHandler = this._throttle(
            this._activityHandler,
            5000,
          ); // 5 seconds

          events.forEach((event) => {
            document.addEventListener(event, this._throttledActivityHandler, {
              passive: true,
            });
          });
        }

        /**
         * Private method to clean up activity monitoring
         */
        _cleanupActivityMonitoring() {
          if (this._throttledActivityHandler) {
            const events = [
              "click",
              "keydown",
              "mousemove",
              "scroll",
              "touchstart",
            ];
            events.forEach((event) => {
              document.removeEventListener(
                event,
                this._throttledActivityHandler,
              );
            });
          }
        }

        /**
         * Private method to throttle function calls
         * @param {Function} func - Function to throttle
         * @param {number} limit - Throttle limit in milliseconds
         * @returns {Function} - Throttled function
         */
        _throttle(func, limit) {
          let inThrottle;
          return function () {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
              func.apply(context, args);
              inThrottle = true;
              setTimeout(() => (inThrottle = false), limit);
            }
          };
        }
      }

      /**
       * OptimisticUI class for immediate user feedback
       * Handles optimistic updates with server confirmation and rollback on errors
       */
      class OptimisticUI {
        constructor() {
          this.pendingUpdates = new Map(); // Track pending optimistic updates
          this.originalStates = new Map(); // Store original states for rollback
        }

        /**
         * Update student status optimistically for immediate UI feedback
         * @param {Object} student - Student object to update
         * @param {string} action - Action being performed ('out' or 'back')
         * @param {string} teacherName - Teacher name
         * @param {Function} updateCallback - Callback to update UI immediately
         * @returns {string} - Update ID for tracking
         */
        updateStudentStatusOptimistically(
          student,
          action,
          teacherName,
          updateCallback,
        ) {
          const updateId = `${student.name}_${action}_${Date.now()}`;

          // Store original state for potential rollback
          this.originalStates.set(updateId, {
            outTime: student.outTime,
            backTime: student.backTime,
            holdNotice: student.holdNotice,
          });

          // Create optimistic state
          const optimisticState = { ...student };
          const now = new Date();
          const timeString = this._formatTimeToHHMM(now);

          if (action === "out") {
            optimisticState.outTime = timeString;
            optimisticState.holdNotice = ""; // Clear hold notice when going out
            console.log(
              `OptimisticUI: Marking ${student.name} OUT optimistically at ${timeString}`,
            );
          } else if (action === "back") {
            optimisticState.backTime = timeString;
            console.log(
              `OptimisticUI: Marking ${student.name} BACK optimistically at ${timeString}`,
            );
          }

          // Track this pending update
          this.pendingUpdates.set(updateId, {
            studentName: student.name,
            action: action,
            teacherName: teacherName,
            optimisticState: optimisticState,
            timestamp: Date.now(),
          });

          // Apply optimistic update to UI immediately
          if (updateCallback) {
            updateCallback(optimisticState);
          }

          console.log(`OptimisticUI: Applied optimistic update ${updateId}`);
          return updateId;
        }

        /**
         * Confirm server update and clean up optimistic state
         * @param {string} updateId - Update ID from optimistic update
         * @param {Object} serverState - Confirmed state from server
         * @param {Function} updateCallback - Callback to update UI with server state
         */
        confirmServerUpdate(updateId, serverState, updateCallback) {
          const pendingUpdate = this.pendingUpdates.get(updateId);

          if (!pendingUpdate) {
            console.warn(
              `OptimisticUI: No pending update found for ID ${updateId}`,
            );
            return;
          }

          console.log(`OptimisticUI: Confirming server update ${updateId}`);

          // Merge server state with any additional server-provided data
          if (updateCallback && serverState) {
            updateCallback(serverState);
          }

          // Clean up tracking
          this.pendingUpdates.delete(updateId);
          this.originalStates.delete(updateId);

          console.log(
            `OptimisticUI: Server update confirmed and cleaned up ${updateId}`,
          );
        }

        /**
         * Revert optimistic update on server error
         * @param {string} updateId - Update ID from optimistic update
         * @param {Function} revertCallback - Callback to revert UI to original state
         * @param {string} errorMessage - Error message for logging
         */
        revertOnError(
          updateId,
          revertCallback,
          errorMessage = "Server update failed",
        ) {
          const pendingUpdate = this.pendingUpdates.get(updateId);
          const originalState = this.originalStates.get(updateId);

          if (!pendingUpdate || !originalState) {
            console.warn(
              `OptimisticUI: Cannot revert - no data found for ID ${updateId}`,
            );
            return;
          }

          console.log(
            `OptimisticUI: Reverting optimistic update ${updateId} due to: ${errorMessage}`,
          );

          // Revert to original state
          if (revertCallback) {
            revertCallback(originalState);
          }

          // Clean up tracking
          this.pendingUpdates.delete(updateId);
          this.originalStates.delete(updateId);

          console.log(
            `OptimisticUI: Reverted update ${updateId} to original state`,
          );
        }

        /**
         * Get all pending updates (for debugging or status display)
         * @returns {Array} - Array of pending update info
         */
        getPendingUpdates() {
          return Array.from(this.pendingUpdates.values()).map((update) => ({
            studentName: update.studentName,
            action: update.action,
            timestamp: update.timestamp,
            age: Date.now() - update.timestamp,
          }));
        }

        /**
         * Clean up old pending updates (in case server never responds)
         * @param {number} maxAgeMs - Maximum age in milliseconds (default: 30 seconds)
         */
        cleanupOldUpdates(maxAgeMs = 30000) {
          const now = Date.now();
          const toRemove = [];

          for (const [updateId, update] of this.pendingUpdates.entries()) {
            if (now - update.timestamp > maxAgeMs) {
              toRemove.push(updateId);
            }
          }

          toRemove.forEach((updateId) => {
            console.warn(
              `OptimisticUI: Cleaning up old pending update ${updateId}`,
            );
            this.pendingUpdates.delete(updateId);
            this.originalStates.delete(updateId);
          });

          return toRemove.length;
        }

        /**
         * Check if a student has pending updates
         * @param {string} studentName - Name of student to check
         * @returns {boolean} - True if student has pending updates
         */
        hasPendingUpdates(studentName) {
          for (const update of this.pendingUpdates.values()) {
            if (update.studentName === studentName) {
              return true;
            }
          }
          return false;
        }

        /**
         * Get pending update info for a specific student
         * @param {string} studentName - Name of student
         * @returns {Object|null} - Pending update info or null
         */
        getPendingUpdateForStudent(studentName) {
          for (const [updateId, update] of this.pendingUpdates.entries()) {
            if (update.studentName === studentName) {
              return {
                updateId: updateId,
                action: update.action,
                timestamp: update.timestamp,
                age: Date.now() - update.timestamp,
              };
            }
          }
          return null;
        }

        /**
         * Clear all pending updates (use with caution)
         */
        clearAllPending() {
          const count = this.pendingUpdates.size;
          this.pendingUpdates.clear();
          this.originalStates.clear();
          console.log(`OptimisticUI: Cleared ${count} pending updates`);
          return count;
        }

        /**
         * Private method to format time consistently
         * @param {Date} date - Date object to format
         * @returns {string} - Formatted time string
         */
        _formatTimeToHHMM(date) {
          let hours = date.getHours();
          const minutes = date.getMinutes().toString().padStart(2, "0");
          const ampm = hours >= 12 ? "PM" : "AM";

          hours = hours % 12;
          hours = hours ? hours : 12;

          return `${hours}:${minutes} ${ampm}`;
        }
      }

      /**
       * LocalDataCache class for browser-side caching
       * Implements localStorage-based caching with versioning and expiration
       */
      class LocalDataCache {
        constructor() {
          this.CACHE_PREFIX = "nams_restroom_";
          this.VERSION = "1.0";
          this.DEFAULT_TTL_MINUTES = 60; // 1 hour default
          this.MAX_CACHE_SIZE = 4 * 1024 * 1024; // 4MB limit for localStorage
        }

        /**
         * Store data in localStorage with TTL and versioning
         * @param {string} key - Cache key
         * @param {any} data - Data to cache
         * @param {number} ttlMinutes - Time to live in minutes
         * @returns {boolean} - Success status
         */
        set(key, data, ttlMinutes = this.DEFAULT_TTL_MINUTES) {
          try {
            const cacheEntry = {
              data: data,
              timestamp: Date.now(),
              expiresAt: Date.now() + ttlMinutes * 60 * 1000,
              version: this.VERSION,
            };

            const serializedData = JSON.stringify(cacheEntry);
            const fullKey = this.CACHE_PREFIX + key;

            // Check cache size before storing
            if (this._wouldExceedCacheLimit(serializedData)) {
              console.warn(
                "Cache size limit would be exceeded, cleaning up old entries",
              );
              this._cleanupOldEntries();

              // Check again after cleanup
              if (this._wouldExceedCacheLimit(serializedData)) {
                console.warn(
                  "Cannot cache data - would exceed size limit even after cleanup",
                );
                return false;
              }
            }

            localStorage.setItem(fullKey, serializedData);
            console.log(
              `LocalCache SET: "${key}" with TTL ${ttlMinutes} minutes`,
            );
            return true;
          } catch (error) {
            console.error(`Error setting local cache key "${key}":`, error);
            // Handle quota exceeded error
            if (error.name === "QuotaExceededError") {
              this._handleQuotaExceeded();
            }
            return false;
          }
        }

        /**
         * Retrieve data from localStorage with TTL validation
         * @param {string} key - Cache key
         * @returns {any|null} - Cached data or null if not found/expired
         */
        get(key) {
          try {
            const fullKey = this.CACHE_PREFIX + key;
            const serializedData = localStorage.getItem(fullKey);

            if (!serializedData) {
              console.log(`LocalCache MISS: "${key}" - not found`);
              return null;
            }

            const cacheEntry = JSON.parse(serializedData);

            // Check version compatibility
            if (cacheEntry.version !== this.VERSION) {
              console.log(`LocalCache MISS: "${key}" - version mismatch`);
              this.invalidate(key);
              return null;
            }

            // Check if expired
            if (Date.now() > cacheEntry.expiresAt) {
              console.log(`LocalCache MISS: "${key}" - expired`);
              this.invalidate(key);
              return null;
            }

            console.log(`LocalCache HIT: "${key}"`);
            return cacheEntry.data;
          } catch (error) {
            console.error(`Error getting local cache key "${key}":`, error);
            return null;
          }
        }

        /**
         * Check if cache entry exists and is valid
         * @param {string} key - Cache key
         * @returns {boolean} - True if valid
         */
        isValid(key) {
          try {
            const fullKey = this.CACHE_PREFIX + key;
            const serializedData = localStorage.getItem(fullKey);

            if (!serializedData) return false;

            const cacheEntry = JSON.parse(serializedData);
            return (
              cacheEntry.version === this.VERSION &&
              Date.now() <= cacheEntry.expiresAt
            );
          } catch (error) {
            return false;
          }
        }

        /**
         * Remove specific cache entry
         * @param {string} key - Cache key to remove
         */
        invalidate(key) {
          try {
            const fullKey = this.CACHE_PREFIX + key;
            localStorage.removeItem(fullKey);
            console.log(`LocalCache INVALIDATED: "${key}"`);
          } catch (error) {
            console.error(
              `Error invalidating local cache key "${key}":`,
              error,
            );
          }
        }

        /**
         * Clear all cache entries for this app
         */
        clearAll() {
          try {
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.CACHE_PREFIX)) {
                keysToRemove.push(key);
              }
            }

            keysToRemove.forEach((key) => localStorage.removeItem(key));
            console.log(`LocalCache cleared ${keysToRemove.length} entries`);
          } catch (error) {
            console.error("Error clearing local cache:", error);
          }
        }

        /**
         * Get cache statistics and info
         * @returns {Object} - Cache statistics
         */
        getStats() {
          try {
            let totalSize = 0;
            let entryCount = 0;
            let expiredCount = 0;
            const now = Date.now();

            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.CACHE_PREFIX)) {
                entryCount++;
                const data = localStorage.getItem(key);
                if (data) {
                  totalSize += data.length;

                  try {
                    const cacheEntry = JSON.parse(data);
                    if (now > cacheEntry.expiresAt) {
                      expiredCount++;
                    }
                  } catch (e) {
                    expiredCount++; // Count parse errors as expired
                  }
                }
              }
            }

            return {
              entryCount,
              expiredCount,
              totalSizeBytes: totalSize,
              totalSizeKB: Math.round(totalSize / 1024),
              maxSizeKB: Math.round(this.MAX_CACHE_SIZE / 1024),
              usagePercent: Math.round((totalSize / this.MAX_CACHE_SIZE) * 100),
            };
          } catch (error) {
            console.error("Error getting cache stats:", error);
            return { error: error.message };
          }
        }

        /**
         * Clean up expired entries
         */
        cleanupExpired() {
          try {
            const keysToRemove = [];
            const now = Date.now();

            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.CACHE_PREFIX)) {
                const data = localStorage.getItem(key);
                if (data) {
                  try {
                    const cacheEntry = JSON.parse(data);
                    if (
                      now > cacheEntry.expiresAt ||
                      cacheEntry.version !== this.VERSION
                    ) {
                      keysToRemove.push(key);
                    }
                  } catch (e) {
                    keysToRemove.push(key); // Remove unparseable entries
                  }
                }
              }
            }

            keysToRemove.forEach((key) => localStorage.removeItem(key));

            if (keysToRemove.length > 0) {
              console.log(
                `LocalCache cleaned up ${keysToRemove.length} expired entries`,
              );
            }

            return keysToRemove.length;
          } catch (error) {
            console.error("Error cleaning up expired cache entries:", error);
            return 0;
          }
        }

        /**
         * Private method to check if adding data would exceed cache limit
         * @param {string} serializedData - Data to be added
         * @returns {boolean} - True if would exceed limit
         */
        _wouldExceedCacheLimit(serializedData) {
          try {
            const stats = this.getStats();
            const newDataSize = serializedData.length;
            return stats.totalSizeBytes + newDataSize > this.MAX_CACHE_SIZE;
          } catch (error) {
            return false; // Assume it's okay if we can't calculate
          }
        }

        /**
         * Private method to clean up old entries when approaching size limit
         */
        _cleanupOldEntries() {
          try {
            const entries = [];

            // Collect all cache entries with timestamps
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.CACHE_PREFIX)) {
                const data = localStorage.getItem(key);
                if (data) {
                  try {
                    const cacheEntry = JSON.parse(data);
                    entries.push({
                      key: key,
                      timestamp: cacheEntry.timestamp,
                      size: data.length,
                    });
                  } catch (e) {
                    // Remove unparseable entries immediately
                    localStorage.removeItem(key);
                  }
                }
              }
            }

            // Sort by timestamp (oldest first) and remove oldest 25%
            entries.sort((a, b) => a.timestamp - b.timestamp);
            const toRemove = Math.ceil(entries.length * 0.25);

            for (let i = 0; i < toRemove; i++) {
              localStorage.removeItem(entries[i].key);
            }

            console.log(
              `LocalCache removed ${toRemove} old entries to free space`,
            );
          } catch (error) {
            console.error("Error cleaning up old cache entries:", error);
          }
        }

        /**
         * Private method to handle quota exceeded errors
         */
        _handleQuotaExceeded() {
          console.warn("LocalStorage quota exceeded, attempting cleanup");

          // First try cleaning expired entries
          const expiredCleaned = this.cleanupExpired();

          // If that's not enough, clean up old entries
          if (expiredCleaned === 0) {
            this._cleanupOldEntries();
          }
        }
      }

      function appData() {
        return {
          dateString: "",
          periodString: "",
          nextPeriodString: "",
          teachers: [],
          detectedTeacher: "",
          userEmail: "",
          students: [],
          isLoading: false,
          loadingMessage: "",
          lastActionTime: 0,
          lastUpdateTimestamp: 0,
          refreshInterval: null,

          // Search functionality
          searchTerm: "",
          searchResults: [],
          allStudents: [], // Cache of all students for dropdown
          showSearchResults: false,
          isSearching: false,
          searchTimeout: null,
          studentsLoaded: false, // Track if we've loaded all students
          highlightedIndex: -1, // For keyboard navigation

          // Initialize LocalDataCache instance
          localCache: new LocalDataCache(),

          // Initialize OptimisticUI instance
          optimisticUI: new OptimisticUI(),

          // Initialize SmartPollingManager instance
          smartPolling: new SmartPollingManager(),

          init() {
            this.loadUserInfo();

            // Update period every minute
            setInterval(() => {
              const now = new Date();
              this.periodString = this.getCurrentPeriod(now);
              this.nextPeriodString = this.getNextPeriod(now);
            }, 60000);

            // Clean up old optimistic updates every 30 seconds
            setInterval(() => {
              const cleaned = this.optimisticUI.cleanupOldUpdates(30000); // 30 seconds
              if (cleaned > 0) {
                console.log(`Cleaned up ${cleaned} old optimistic updates`);
              }
            }, 30000);

            // Clean up expired cache entries every 5 minutes
            setInterval(() => {
              const cleaned = this.localCache.cleanupExpired();
              if (cleaned > 0) {
                console.log(`Cleaned up ${cleaned} expired cache entries`);
              }
            }, 300000);

            // Log performance stats every 10 minutes for monitoring
            setInterval(() => {
              this._logPerformanceReport();
            }, 600000); // 10 minutes

            // Also log performance stats every 2 minutes during active usage
            setInterval(() => {
              const pollingStats = this.smartPolling.getStats();
              if (pollingStats.activityLevel === "active") {
                this._logPerformanceReport(true);
              }
            }, 120000); // 2 minutes
          },

          // Method to get comprehensive performance stats
          getPerformanceStats() {
            return {
              polling: this.smartPolling.getStats(),
              cache: this.localCache.getStats(),
              optimisticUpdates: this.optimisticUI.getPendingUpdates(),
              lastUpdateTimestamp: this.lastUpdateTimestamp,
              lastActionTime: this.lastActionTime,
            };
          },

          // Bell Schedule Configuration
          // Unified NAMS Bell Schedule 2025-2026 (combining 4th & 5th periods)
          getBellSchedule() {
            return [
              { period: "1st", start: "8:40", end: "9:26" },
              { period: "2nd", start: "9:30", end: "10:16" },
              { period: "3rd", start: "10:20", end: "11:06" },
              { period: "4th & 5th", start: "11:10", end: "1:21" },
              { period: "6th", start: "1:25", end: "2:11" },
              { period: "7th", start: "2:15", end: "3:01" },
              { period: "8th", start: "3:05", end: "3:55" },
            ];
          },

          // Convert time string (e.g., "8:40", "1:21") to minutes since midnight
          // Assumes times after 1:00 and before 8:00 are PM
          timeToMinutes(timeStr) {
            const [hours, minutes] = timeStr.split(":").map(Number);
            let adjustedHours = hours;

            // Convert to 24-hour format
            // Times from 1:00 to 7:59 are assumed to be PM (afternoon/evening)
            if (hours >= 1 && hours <= 7) {
              adjustedHours = hours + 12;
            }

            const result = adjustedHours * 60 + minutes;
            console.log(
              `timeToMinutes("${timeStr}") = ${adjustedHours}*60 + ${minutes} = ${result} (original hours: ${hours})`,
            );
            return result;
          },

          // Get the current period based on time
          getCurrentPeriod(now = new Date()) {
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.

            // Debug logging
            console.log("Current time debug:", {
              fullDate: now.toString(),
              hours: now.getHours(),
              minutes: now.getMinutes(),
              currentTimeInMinutes: currentTime,
              dayOfWeek: dayOfWeek,
              timeString: now.toLocaleTimeString(),
            });

            // School only operates Monday-Friday
            if (dayOfWeek === 0 || dayOfWeek === 6) {
              return "Weekend - No School";
            }

            // Before school starts (8:40 = 520 minutes)
            const schoolStartMinutes = this.timeToMinutes("8:40");
            console.log(
              "School start check:",
              currentTime,
              "<",
              schoolStartMinutes,
              "=",
              currentTime < schoolStartMinutes,
            );
            if (currentTime < schoolStartMinutes) {
              return "Before School";
            }

            // After school ends (3:55 = 955 minutes)
            const schoolEndMinutes = this.timeToMinutes("3:55");
            console.log(
              "School end check:",
              currentTime,
              ">",
              schoolEndMinutes,
              "=",
              currentTime > schoolEndMinutes,
            );
            if (currentTime > schoolEndMinutes) {
              return "After School";
            }

            // Get the unified schedule
            const periods = this.getBellSchedule();

            // Check each period
            for (const period of periods) {
              const startTime = this.timeToMinutes(period.start);
              const endTime = this.timeToMinutes(period.end);

              console.log(
                `Checking ${period.period}:`,
                currentTime,
                "between",
                startTime,
                "and",
                endTime,
              );

              if (currentTime >= startTime && currentTime <= endTime) {
                return `${period.period} (${period.start} - ${period.end})`;
              }
            }

            // Check for passing periods (between classes)
            for (let i = 0; i < periods.length - 1; i++) {
              const currentPeriodEnd = this.timeToMinutes(periods[i].end);
              const nextPeriodStart = this.timeToMinutes(periods[i + 1].start);

              if (
                currentTime > currentPeriodEnd &&
                currentTime < nextPeriodStart
              ) {
                return `Passing Period (${periods[i].period} → ${periods[i + 1].period})`;
              }
            }

            return `Current Time: ${now.toLocaleTimeString()} (${currentTime} minutes)`;
          },

          // Get information about the next period
          getNextPeriod(now = new Date()) {
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const dayOfWeek = now.getDay();

            // School only operates Monday-Friday
            if (dayOfWeek === 0 || dayOfWeek === 6) {
              return "No upcoming periods - Weekend";
            }

            // After school ends
            if (currentTime > this.timeToMinutes("3:55")) {
              return "No more periods today";
            }

            const periods = this.getBellSchedule();

            // Find the next period that hasn't started yet
            for (const period of periods) {
              const startTime = this.timeToMinutes(period.start);

              if (currentTime < startTime) {
                const minutesUntil = startTime - currentTime;
                const hours = Math.floor(minutesUntil / 60);
                const mins = minutesUntil % 60;

                let timeUntil = "";
                if (hours > 0) {
                  timeUntil = `${hours}h ${mins}m`;
                } else {
                  timeUntil = `${mins}m`;
                }

                return `Next: ${period.period} in ${timeUntil} (${period.start} - ${period.end})`;
              }
            }

            return "No more periods today";
          },

          loadUserInfo() {
            console.log("Loading user information...");

            // Try to get cached user info first
            const cachedUserInfo = this.localCache.get("userInfo");
            const cachedTeachers = this.localCache.get("teacherList");

            if (cachedUserInfo && cachedTeachers) {
              console.log("Using cached user info and teacher list");
              this.userEmail = cachedUserInfo.userEmail;
              this.detectedTeacher = cachedUserInfo.detectedTeacher;
              this.teachers = cachedTeachers;

              this._initializeDateAndPeriod();
              this.refreshData();
              this.startSmartRefresh();

              // Still fetch fresh data in background to update cache
              this._fetchUserInfoInBackground();
              return;
            }

            // No cache available, fetch from server
            this._fetchUserInfoFromServer();
          },

          _fetchUserInfoFromServer() {
            google.script.run
              .withSuccessHandler((userInfo) => {
                console.log("User info received:", userInfo);
                this.userEmail = userInfo.userEmail;
                this.detectedTeacher = userInfo.detectedTeacher;
                this.teachers = userInfo.teacherList;

                // Cache the user info and teacher list
                this.localCache.set(
                  "userInfo",
                  {
                    userEmail: userInfo.userEmail,
                    detectedTeacher: userInfo.detectedTeacher,
                  },
                  1440,
                ); // Cache for 24 hours

                this.localCache.set("teacherList", userInfo.teacherList, 1440); // Cache for 24 hours

                this._initializeDateAndPeriod();
                this.refreshData();
                this.startSmartRefresh();
              })
              .withFailureHandler((error) => {
                console.error("Error loading user info:", error);
                this._useFallbackUserInfo();
              })
              .api_getCurrentUserInfo();
          },

          _fetchUserInfoInBackground() {
            // Silently fetch fresh user info to update cache
            google.script.run
              .withSuccessHandler((userInfo) => {
                console.log("Background user info update received");
                // Update cache with fresh data
                this.localCache.set(
                  "userInfo",
                  {
                    userEmail: userInfo.userEmail,
                    detectedTeacher: userInfo.detectedTeacher,
                  },
                  1440,
                );

                this.localCache.set("teacherList", userInfo.teacherList, 1440);

                // Update current data if significantly different
                if (userInfo.detectedTeacher !== this.detectedTeacher) {
                  this.detectedTeacher = userInfo.detectedTeacher;
                  console.log("Updated detected teacher from background fetch");
                }
              })
              .withFailureHandler((error) => {
                console.log(
                  "Background user info fetch failed (not critical):",
                  error,
                );
              })
              .api_getCurrentUserInfo();
          },

          _useFallbackUserInfo() {
            // Use fallback teacher list
            const fallbackTeachers = [
              "Mr. Aguilar",
              "Mrs. Atoui",
              "Mrs. Bowery",
              "Mrs. Cantu",
              "Mr. Casanova",
              "Mrs. Coyle",
              "Mr. De Leon",
              "Mrs. Farias",
              "Mr. Franco",
              "Mr. Garcia",
              "Mr. Goff",
              "Mr. Gomez",
              "Dr. Gonzales",
              "Mr. Hernandez",
              "Mrs. Hutton",
              "Mrs. Idrogo",
              "Mrs. Jasso",
              "Mrs. Marquez",
              "Mr. Ollendieck",
              "Mr. Paez",
              "Mr. Ramon",
              "Mrs. Tellez",
              "Mr. Trevino",
              "Mrs. Wine",
              "Mrs. Yeager",
              "Other Teacher",
            ];

            this.teachers = fallbackTeachers;
            this.detectedTeacher = "Other Teacher";

            // Cache fallback data
            this.localCache.set("teacherList", fallbackTeachers, 60); // Cache for 1 hour only
            this.localCache.set(
              "userInfo",
              {
                userEmail: "",
                detectedTeacher: "Other Teacher",
              },
              60,
            );

            this._initializeDateAndPeriod();
            this.refreshData();
            this.startSmartRefresh();
          },

          _initializeDateAndPeriod() {
            const now = new Date();
            this.dateString = now.toLocaleDateString("en-US", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
            });
            this.periodString = this.getCurrentPeriod(now);
            this.nextPeriodString = this.getNextPeriod(now);
          },

          // Ultra simple test with hardcoded data
          testUltraSimple() {
            console.log("Testing ultra simple...");
            google.script.run
              .withSuccessHandler((resp) => {
                console.log("Ultra simple response:", resp);
                if (resp && resp.students) {
                  alert(
                    `Ultra Simple SUCCESS!\nStudents: ${resp.students.length}`,
                  );
                  this.handleFetch(resp);
                } else {
                  alert(
                    `Ultra Simple FAILED - received: ${JSON.stringify(resp)}`,
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error("Ultra simple failed:", error);
                alert(`Ultra simple failed: ${error.message || error}`);
              })
              .api_ultraSimpleTest();
          },

          // Test roster only (no status processing)
          testRosterOnly() {
            console.log("Testing roster only...");
            google.script.run
              .withSuccessHandler((resp) => {
                console.log("Roster only response:", resp);
                if (resp && resp.students) {
                  alert(
                    `Roster Only SUCCESS!\nStudents: ${resp.students.length}\nFirst: ${resp.students[0] ? resp.students[0].name : "None"}`,
                  );
                  this.handleFetch(resp);
                } else {
                  alert(
                    `Roster Only FAILED - received: ${JSON.stringify(resp)}`,
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error("Roster only failed:", error);
                alert(`Roster only failed: ${error.message || error}`);
              })
              .api_testRosterOnly();
          },

          // Test minimal bypass version (no status processing at all)
          testMinimalBypass() {
            console.log("Testing MINIMAL bypass version...");
            google.script.run
              .withSuccessHandler((resp) => {
                console.log("Minimal bypass response:", resp);
                if (resp && resp.students) {
                  alert(
                    `MINIMAL BYPASS SUCCESS!\nStudents: ${resp.students.length}\nFirst student: ${resp.students[0] ? resp.students[0].name : "None"}\nNo status processing!`,
                  );
                  // Load this data into the interface
                  this.students = resp.students;
                } else {
                  console.error(
                    "Minimal bypass returned invalid structure:",
                    resp,
                  );
                  alert(
                    "Minimal bypass returned invalid data: " +
                      JSON.stringify(resp),
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error("Minimal bypass failed:", error);
                alert(`Minimal bypass failed: ${error.message || error}`);
              })
              .api_minimalBypass();
          },

          // Test the October 16 version
          testOctober16() {
            console.log("Testing October 16 2025 version...");
            google.script.run
              .withSuccessHandler((resp) => {
                console.log("October 16 response:", resp);
                if (resp && resp.students) {
                  alert(
                    `OCTOBER 16 SUCCESS!\nStudents: ${resp.students.length}\nFirst student: ${resp.students[0] ? resp.students[0].name : "None"}`,
                  );
                  // Load this data into the interface
                  this.students = resp.students;
                } else {
                  console.error("October 16 returned invalid structure:", resp);
                  alert(
                    "October 16 returned invalid data: " + JSON.stringify(resp),
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error("October 16 failed:", error);
                alert(`October 16 failed: ${error.message || error}`);
              })
              .api_october16_2025();
          },

          // Test the new function
          testNewFunction() {
            console.log("Testing FINAL working version...");
            google.script.run
              .withSuccessHandler((resp) => {
                console.log("Final version response:", resp);
                if (resp && resp.students) {
                  alert(
                    `FINAL VERSION SUCCESS!\nStudents: ${resp.students.length}\nFirst student: ${resp.students[0] ? resp.students[0].name : "None"}`,
                  );
                  // Load this data into the interface
                  this.students = resp.students;
                } else {
                  console.error(
                    "Final version returned invalid structure:",
                    resp,
                  );
                  alert(
                    "Final version returned invalid data: " +
                      JSON.stringify(resp),
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error("Final version failed:", error);
                alert(`Final version failed: ${error.message || error}`);
              })
              .api_finalWorkingVersion();
          },

          refreshData() {
            console.log(
              "refreshData() called - loading active students",
            );

            // Load only active students (those currently being managed)
            this.isLoading = true;
            this.loadingMessage = "Loading active students...";
            this.loadStartTime = Date.now();

            google.script.run
              .withSuccessHandler((response) => {
                const responseTime = Date.now() - this.loadStartTime;
                console.log(
                  "✓ Active students loaded successfully:",
                  response,
                );
                console.log(`📊 Load response time: ${responseTime}ms`);

                if (
                  response &&
                  response.success &&
                  response.data
                ) {
                  console.log(
                    `Active students: ${response.metadata.activeStudentCount}`,
                  );
                  this._handleStudentDataSuccess(response.data);

                  // Start smart polling after successful initial load
                  this.startSmartRefresh();
                } else {
                  console.warn("Active students endpoint failed:", response?.error);
                  this.isLoading = false;
                  this.loadingMessage = "";
                }
              })
              .withFailureHandler((error) => {
                const responseTime = Date.now() - this.loadStartTime;
                console.error("Active students endpoint failed:", error);
                console.log(`📊 Failed load response time: ${responseTime}ms`);
                this.isLoading = false;
                this.loadingMessage = "";
              })
              .api_getActiveStudents();
          },

          _fetchStudentDataFromServer() {
            console.log(
              "Fetching student data from server with optimized cached loading",
            );
            this.isLoading = true;
            this.loadingMessage = "Loading student data...";
            this.loadStartTime = Date.now(); // Track load start time

            // Use the optimized cached data endpoint first
            google.script.run
              .withSuccessHandler((response) => {
                const responseTime = Date.now() - this.loadStartTime;
                console.log(
                  "✓ Cached student data loaded successfully:",
                  response,
                );
                console.log(`📊 Server response time: ${responseTime}ms`);

                if (
                  response &&
                  response.success &&
                  response.data &&
                  response.data.students
                ) {
                  console.log(
                    `Cache used: ${response.metadata.cacheUsed}, Students: ${response.metadata.studentCount}`,
                  );

                  // Log cache hit/miss
                  if (response.metadata.cacheUsed) {
                    console.log("📊 Cache HIT - Data served from server cache");
                  } else {
                    console.log(
                      "📊 Cache MISS - Data loaded fresh from sheets",
                    );
                  }

                  this._handleStudentDataSuccess(response.data);
                } else if (response && !response.success) {
                  console.warn(
                    "Cached endpoint failed, falling back...",
                    response.error,
                  );
                  this.loadingMessage = "Trying fallback method...";
                  this.fallbackToMinimalBypass();
                } else {
                  console.warn(
                    "Cached endpoint returned invalid data, falling back...",
                  );
                  this.loadingMessage = "Trying fallback method...";
                  this.fallbackToMinimalBypass();
                }
              })
              .withFailureHandler((error) => {
                const responseTime = Date.now() - this.loadStartTime;
                console.error("Cached endpoint failed:", error);
                console.log(`📊 Failed response time: ${responseTime}ms`);
                this.loadingMessage = "Trying fallback method...";
                this.fallbackToMinimalBypass();
              })
              .api_getActiveStudents();
          },

          _fetchStudentDataInBackground() {
            console.log(
              "Fetching fresh student data in background using optimized endpoint",
            );

            // Fetch fresh data without loading indicator using optimized cached endpoint
            google.script.run
              .withSuccessHandler((response) => {
                console.log("Background student data update received");

                if (
                  response &&
                  response.success &&
                  response.data &&
                  response.data.students
                ) {
                  const data = response.data;

                  // Check if data has actually changed before updating UI
                  const hasChanges = this._hasStudentDataChanged(data);

                  if (hasChanges) {
                    console.log("Student data changes detected, updating UI");
                    this._handleStudentDataSuccess(data, false); // false = no loading indicator
                  } else {
                    console.log("No student data changes detected");
                    // Still update cache with fresh timestamp
                    this.localCache.set("studentData", data, 30); // 30 minutes cache
                  }
                } else {
                  console.log(
                    "Background fetch returned invalid data (not critical):",
                    response,
                  );
                }
              })
              .withFailureHandler((error) => {
                console.log(
                  "Background student data fetch failed (not critical):",
                  error,
                );
              })
              .api_getActiveStudents();
          },

          _handleStudentDataSuccess(data, showLoading = true) {
            const startTime = this.loadStartTime || Date.now();
            const loadTime = Date.now() - startTime;

            this.students = data.students;

            // Cache the student data
            this.localCache.set("studentData", data, 30); // Cache for 30 minutes

            if (showLoading) {
              this.isLoading = false;
              this.loadingMessage = "";
            }

            this.lastUpdateTimestamp = Date.now();

            // Performance monitoring and validation
            console.log("✓ Student data applied successfully");
            console.log(`📊 Load time: ${loadTime}ms`);

            // Validate performance targets
            this._validatePerformanceTargets(loadTime, showLoading);

            // Log cache statistics
            this._logCacheStatistics();
          },

          // Validate that performance targets are met
          _validatePerformanceTargets(loadTime, isInitialLoad) {
            const targetInitialLoad = 3000; // 3 seconds for initial load
            const targetUpdate = 1000; // 1 second for updates

            const target = isInitialLoad ? targetInitialLoad : targetUpdate;
            const targetType = isInitialLoad ? "initial load" : "update";

            if (loadTime <= target) {
              console.log(
                `✅ Performance target met: ${targetType} completed in ${loadTime}ms (target: ${target}ms)`,
              );
            } else {
              console.warn(
                `⚠️ Performance target missed: ${targetType} took ${loadTime}ms (target: ${target}ms)`,
              );
            }

            // Store performance metrics for monitoring
            if (!this.performanceMetrics) {
              this.performanceMetrics = {
                loadTimes: [],
                updateTimes: [],
                targetsMet: 0,
                targetsMissed: 0,
              };
            }

            if (isInitialLoad) {
              this.performanceMetrics.loadTimes.push(loadTime);
            } else {
              this.performanceMetrics.updateTimes.push(loadTime);
            }

            if (loadTime <= target) {
              this.performanceMetrics.targetsMet++;
            } else {
              this.performanceMetrics.targetsMissed++;
            }
          },

          // Log cache statistics for monitoring
          _logCacheStatistics() {
            const cacheStats = this.localCache.getStats();
            const pollingStats = this.smartPolling.getStats();

            console.log("📊 Cache Statistics:", {
              hitRate:
                cacheStats.entryCount > 0
                  ? `${Math.round(((cacheStats.entryCount - cacheStats.expiredCount) / cacheStats.entryCount) * 100)}%`
                  : "0%",
              size: `${cacheStats.totalSizeKB}KB`,
              usage: `${cacheStats.usagePercent}%`,
              entries: cacheStats.entryCount,
              expired: cacheStats.expiredCount,
            });

            console.log("📊 Polling Statistics:", {
              activityLevel: pollingStats.activityLevel,
              updateRate: pollingStats.updateRate,
              totalChecks: pollingStats.totalChecks,
              updatesFound: pollingStats.updatesFound,
              averageInterval: `${Math.round(pollingStats.averageInterval / 1000)}s`,
            });
          },

          _hasStudentDataChanged(newData) {
            // Simple comparison - check if student count or queue lengths changed
            if (
              !this.students ||
              this.students.length !== newData.students.length
            ) {
              return true;
            }



            // Check for status changes in first few students (most likely to change)
            for (let i = 0; i < Math.min(5, this.students.length); i++) {
              const current = this.students[i];
              const updated = newData.students[i];

              if (
                current &&
                updated &&
                (current.outTime !== updated.outTime ||
                  current.backTime !== updated.backTime ||
                  current.holdNotice !== updated.holdNotice)
              ) {
                return true;
              }
            }

            return false;
          },

          // Start smart refresh system using SmartPollingManager
          startSmartRefresh() {
            console.log(
              "Starting smart refresh system with SmartPollingManager...",
            );

            // Initialize last update timestamp
            this.lastUpdateTimestamp = Date.now();

            // Start adaptive polling with update callback
            this.smartPolling.startAdaptivePolling(
              (updateInfo) => {
                // Update callback - called when updates are detected
                console.log("SmartPolling detected updates:", updateInfo);

                if (updateInfo.fallback) {
                  // Fallback mode - do full refresh
                  console.log(
                    "Using fallback mode - performing full refresh...",
                  );
                  this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
                  this._fetchStudentDataInBackground();
                } else if (
                  updateInfo &&
                  updateInfo.success &&
                  updateInfo.hasUpdates
                ) {
                  // Incremental updates available
                  console.log("Processing incremental updates...");
                  this._handleIncrementalUpdates(updateInfo);
                  this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
                } else if (
                  updateInfo &&
                  updateInfo.success &&
                  !updateInfo.hasUpdates
                ) {
                  // No updates, just update timestamp
                  console.log("No updates detected, keeping current data");
                  this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
                } else {
                  // Unknown response, do full refresh to be safe
                  console.log(
                    "Unknown update response, performing full refresh...",
                  );
                  this.lastUpdateTimestamp = Date.now();
                  this._fetchStudentDataInBackground();
                }
              },
              (activityLevel) => {
                // Activity level change callback
                console.log(`User activity level changed to: ${activityLevel}`);
              },
            );
          },

          // Handle incremental updates from the optimized endpoint
          _handleIncrementalUpdates(updateInfo) {
            console.log("Handling incremental updates:", updateInfo);

            if (!updateInfo.updates || !updateInfo.changedStudents) {
              console.log(
                "No specific update data, falling back to full refresh",
              );
              this._fetchStudentDataInBackground();
              return;
            }

            let hasChanges = false;

            // Update specific students that have changed
            updateInfo.changedStudents.forEach((studentName) => {
              const studentUpdate = updateInfo.updates[studentName];
              if (!studentUpdate) return;

              const studentIndex = this.students.findIndex(
                (s) => s.name === studentName,
              );
              if (studentIndex !== -1) {
                const currentStudent = this.students[studentIndex];

                // Check if there are actual changes
                if (
                  currentStudent.outTime !== studentUpdate.outTime ||
                  currentStudent.backTime !== studentUpdate.backTime ||
                  currentStudent.holdNotice !== studentUpdate.holdNotice ||
                  currentStudent.gender !== studentUpdate.gender ||
                  currentStudent.teacher !== studentUpdate.teacher
                ) {
                  // Apply the update
                  this.students[studentIndex] = {
                    ...currentStudent,
                    gender: studentUpdate.gender || currentStudent.gender,
                    teacher: studentUpdate.teacher || currentStudent.teacher,
                    outTime: studentUpdate.outTime || "",
                    backTime: studentUpdate.backTime || "",
                    holdNotice: studentUpdate.holdNotice || "",
                  };

                  hasChanges = true;
                  console.log(`Updated student ${studentName} incrementally`);
                }
              }
            });

            if (hasChanges) {
              // Update local cache with new data
              this.localCache.set(
                "studentData",
                {
                  students: this.students,
                },
                30,
              );

              console.log("Incremental updates applied successfully");
            } else {
              console.log("No actual changes detected in incremental update");
            }
          },



          // Stop smart refresh system
          stopSmartRefresh() {
            console.log("Stopping smart refresh system...");
            if (this.refreshInterval) {
              clearInterval(this.refreshInterval);
              this.refreshInterval = null;
            }
            this.smartPolling.stopPolling();
          },

          // Track user actions and notify SmartPollingManager
          recordUserAction() {
            this.lastActionTime = Date.now();
            this.smartPolling.recordUserActivity();
            console.log(
              "User action recorded and reported to SmartPollingManager",
            );
          },

          // Manual refresh triggered by user
          manualRefresh() {
            console.log("Manual refresh triggered by user");
            this.recordUserAction();

            // Clear local cache to force fresh data
            this.localCache.clearAll();

            // Refresh only active students (not all students from roster)
            this.refreshData();
          },

          // Format timestamp for display
          formatTimestamp(timestamp) {
            if (!timestamp) return "Never";

            const now = Date.now();
            const diff = now - timestamp;

            if (diff < 60000) {
              // Less than 1 minute
              return `${Math.round(diff / 1000)}s ago`;
            } else if (diff < 3600000) {
              // Less than 1 hour
              return `${Math.round(diff / 60000)}m ago`;
            } else {
              return new Date(timestamp).toLocaleTimeString();
            }
          },

          // Format last update time for display
          formatLastUpdate() {
            return this.formatTimestamp(this.lastUpdateTimestamp);
          },

          // Log comprehensive performance report
          _logPerformanceReport(isActiveReport = false) {
            const pollingStats = this.smartPolling.getStats();
            const cacheStats = this.localCache.getStats();
            const perfMetrics = this.performanceMetrics || {
              loadTimes: [],
              updateTimes: [],
              targetsMet: 0,
              targetsMissed: 0,
            };

            const avgLoadTime =
              perfMetrics.loadTimes.length > 0
                ? Math.round(
                    perfMetrics.loadTimes.reduce((a, b) => a + b, 0) /
                      perfMetrics.loadTimes.length,
                  )
                : 0;

            const avgUpdateTime =
              perfMetrics.updateTimes.length > 0
                ? Math.round(
                    perfMetrics.updateTimes.reduce((a, b) => a + b, 0) /
                      perfMetrics.updateTimes.length,
                  )
                : 0;

            const totalTargets =
              perfMetrics.targetsMet + perfMetrics.targetsMissed;
            const targetSuccessRate =
              totalTargets > 0
                ? Math.round((perfMetrics.targetsMet / totalTargets) * 100)
                : 100; // 100% if no targets measured yet

            const reportType = isActiveReport ? "ACTIVE USER" : "PERIODIC";

            console.log(`📊 ${reportType} PERFORMANCE REPORT:`);
            console.log("Performance Targets:", {
              successRate: `${targetSuccessRate}%`,
              avgLoadTime: `${avgLoadTime}ms`,
              avgUpdateTime: `${avgUpdateTime}ms`,
              loadOps: perfMetrics.loadTimes.length,
              updateOps: perfMetrics.updateTimes.length,
              targetsMet: perfMetrics.targetsMet,
              targetsMissed: perfMetrics.targetsMissed,
            });

            console.log("Smart Polling:", {
              activityLevel: pollingStats.activityLevel,
              updateRate: pollingStats.updateRate,
              totalChecks: pollingStats.totalChecks,
              updatesFound: pollingStats.updatesFound,
              avgInterval: `${Math.round(pollingStats.averageInterval / 1000)}s`,
              timeSinceActivity: `${Math.round(pollingStats.timeSinceLastActivity / 1000)}s`,
            });

            console.log("Cache Performance:", {
              hitRate: `${cacheStats.entryCount > 0 ? Math.round(((cacheStats.entryCount - cacheStats.expiredCount) / cacheStats.entryCount) * 100) : 0}%`,
              usage: `${cacheStats.usagePercent}%`,
              size: `${cacheStats.totalSizeKB}KB`,
              entries: cacheStats.entryCount,
              expired: cacheStats.expiredCount,
            });

            const pendingUpdates = this.optimisticUI.getPendingUpdates();
            if (pendingUpdates.length > 0) {
              console.log("Optimistic Updates:", {
                pending: pendingUpdates.length,
                oldestAge: `${Math.round(Math.max(...pendingUpdates.map((u) => u.age)) / 1000)}s`,
              });
            }

            // Alert if performance is degraded
            if (targetSuccessRate < 80 && totalTargets >= 5) {
              console.warn(
                `⚠️ Performance Alert: Target success rate is ${targetSuccessRate}% (below 80%)`,
              );
            }

            if (avgLoadTime > 5000 && perfMetrics.loadTimes.length >= 3) {
              console.warn(
                `⚠️ Performance Alert: Average load time is ${avgLoadTime}ms (above 5000ms)`,
              );
            }

            if (avgUpdateTime > 2000 && perfMetrics.updateTimes.length >= 5) {
              console.warn(
                `⚠️ Performance Alert: Average update time is ${avgUpdateTime}ms (above 2000ms)`,
              );
            }
          },

          fallbackToMinimalBypass() {
            console.log("Using fallback: loading active students only");

            google.script.run
              .withSuccessHandler((response) => {
                console.log("Fallback active students received:", response);

                if (response && response.success && response.data) {
                  this._handleStudentDataSuccess(response.data);
                } else {
                  console.error("Even fallback failed:", response);
                  // Initialize with empty data instead of failing
                  this.students = [];
                  this.isLoading = false;
                  this.loadingMessage = "";
                }
              })
              .withFailureHandler((error) => {
                console.error("Fallback also failed:", error);
                // Initialize with empty data instead of showing alert
                this.students = [];
                this.isLoading = false;
                this.loadingMessage = "";
              })
              .api_getActiveStudents();
          },

          // Fallback method for update operations when optimized endpoints fail
          _fallbackUpdateStatus(
            studentName,
            action,
            teacherName,
            gender,
            updateId,
          ) {
            console.log(
              "Using fallback update method for:",
              studentName,
              action,
            );

            google.script.run
              .withSuccessHandler((resp) => {
                console.log("Fallback update successful:", resp);

                // Confirm optimistic update with server response
                this.optimisticUI.confirmServerUpdate(
                  updateId,
                  resp,
                  (serverState) => {
                    console.log(
                      "Fallback update confirmed, triggering immediate data sync",
                    );
                    // Trigger immediate background refresh and smart polling check
                    setTimeout(() => {
                      this._fetchStudentDataInBackground();
                      // Also trigger immediate smart polling check for other potential updates
                      if (this.smartPolling && this.smartPolling.isActive) {
                        this.smartPolling.checkForUpdates();
                      }
                    }, 100); // Small delay to ensure server-side processing is complete
                  },
                );
              })
              .withFailureHandler((error) => {
                console.error("Fallback update also failed:", error);

                // Revert optimistic update on error
                this.optimisticUI.revertOnError(
                  updateId,
                  (originalState) => {
                    // Revert the student object
                    const studentIndex = this.students.findIndex(
                      (s) => s.name === studentName,
                    );
                    if (studentIndex !== -1) {
                      this.students[studentIndex] = {
                        ...this.students[studentIndex],
                        ...originalState,
                      };

                      // Restore to queue if they were originally waiting (for 'out' action)
                      if (
                        action === "out" &&
                        originalState.holdNotice &&
                        !originalState.outTime
                      ) {

                      }
                    }
                  },
                  error.message || error,
                );

                alert(
                  `Error updating student status: ${error.message || error}\n\nThe change has been reverted.`,
                );
              })
              .api_updateStatus(studentName, action, teacherName, gender);
          },

          mergeLogDataFallback() {
            console.log("Attempting to merge log data in fallback mode");

            google.script.run
              .withSuccessHandler((logData) => {
                console.log("Fallback log data received:", logData);

                if (
                  logData &&
                  logData.todaysEntries &&
                  Array.isArray(logData.todaysEntries)
                ) {
                  const logEntries = logData.todaysEntries;
                  console.log(
                    `Merging ${logEntries.length} log entries in fallback mode`,
                  );

                  // Merge log data into existing students
                  this.students = this.students.map((student) => {
                    const studentLogs = logEntries.filter(
                      (log) => log.studentName === student.name,
                    );

                    if (studentLogs.length > 0) {
                      const latestLog = studentLogs[studentLogs.length - 1];
                      console.log(
                        `Fallback merge for ${student.name}:`,
                        latestLog,
                      );

                      return {
                        ...student,
                        gender: latestLog.gender || student.gender,
                        teacher: latestLog.teacher || student.teacher,
                        outTime: latestLog.outTime
                          ? this.formatDate(latestLog.outTime)
                          : student.outTime,
                        backTime: latestLog.backTime
                          ? this.formatDate(latestLog.backTime)
                          : student.backTime,
                        holdNotice: latestLog.holdNotice || student.holdNotice,
                      };
                    }

                    return student;
                  });

                  console.log("Fallback log merge completed successfully");
                } else {
                  console.log("No log entries to merge in fallback mode");
                }

                // Clear loading state after merge completes
                this.isLoading = false;
                this.loadingMessage = "";
              })
              .withFailureHandler((error) => {
                console.warn("Fallback log merge failed:", error);
                // Continue without log data - don't show error to user since we have basic roster
                this.isLoading = false;
                this.loadingMessage = "";
              })
              .api_debugLogSheet();
          },

          handleFetch(resp) {
            // Check if response is valid
            if (!resp) {
              console.error("Received null response from fetchData");
              alert(
                "Error: No data received from server. Please refresh the page.",
              );
              return;
            }

            if (!resp.students || !Array.isArray(resp.students)) {
              console.error("Invalid response structure:", resp);
              alert(
                "Error: Invalid data structure received from server. Please refresh the page.",
              );
              return;
            }

            // resp has { students, queue }
            console.log("Processing students:", resp.students);
            console.log(
              "Detected teacher for assignment:",
              this.detectedTeacher,
            );

            this.students = resp.students.map((s) => {
              // Since student data from daily sheet doesn't include teacher,
              // assign all students to the currently logged-in teacher
              const assignedTeacher =
                this.detectedTeacher || this.teachers[0] || "Other Teacher";

              const processedStudent = {
                name: s.name,
                gender: s.gender || "",
                teacher: s.teacher || assignedTeacher,
                outTime: s.outTime ? this.formatDate(s.outTime) : "",
                backTime: s.backTime ? this.formatDate(s.backTime) : "",
                holdNotice: s.holdNotice || "",
              };

              // Ensure teacher is always set to detected teacher if not already assigned
              if (
                !processedStudent.teacher ||
                processedStudent.teacher.trim() === "" ||
                processedStudent.teacher === "Select Teacher"
              ) {
                processedStudent.teacher = assignedTeacher;
                console.log(
                  `Assigned teacher "${assignedTeacher}" to student "${s.name}"`,
                );
              }

              // Debug first few students
              if (resp.students.indexOf(s) < 3) {
                console.log(`Student ${s.name}:`, s);
                console.log(`Processed ${s.name}:`, processedStudent);
                console.log(
                  `${s.name} teacher assignment: "${processedStudent.teacher}"`,
                );
              }

              return processedStudent;
            });

            console.log("Final students array:", this.students);
            // Set dateString and periodString
            const now = new Date();
            this.dateString = now.toLocaleDateString("en-US", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
            });
            this.periodString = this.getCurrentPeriod(now);
            this.nextPeriodString = this.getNextPeriod(now);
          },

          formatDate(dt) {
            if (!dt) return "";

            // Check if it's already a formatted time string (like "2:30 PM")
            if (typeof dt === "string" && dt.match(/^\d{1,2}:\d{2} (AM|PM)$/)) {
              return dt; // Already formatted, return as-is
            }

            // Check if it's already a string that's not a valid date
            if (typeof dt === "string" && isNaN(Date.parse(dt))) {
              return dt; // Return as-is if it's not a valid date string
            }

            const d = new Date(dt);
            if (isNaN(d.getTime())) {
              return dt; // Return original value if invalid date
            }

            // Format to 12-hour time with AM/PM (matching backend format)
            let hours = d.getHours();
            const minutes = d.getMinutes().toString().padStart(2, "0");
            const ampm = hours >= 12 ? "PM" : "AM";

            // Convert to 12-hour format
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12

            return `${hours}:${minutes} ${ampm}`;
          },

          // Format time for display in the UI
          formatTime(timeStr) {
            if (!timeStr) return "";

            // If it's already in "H:MM AM/PM" format, return as-is
            if (
              typeof timeStr === "string" &&
              timeStr.match(/^\d{1,2}:\d{2} (AM|PM)$/)
            ) {
              return timeStr;
            }

            // If it's a hold notice or other text, return as-is
            if (typeof timeStr === "string" && isNaN(Date.parse(timeStr))) {
              return timeStr;
            }

            // Try to parse and format as time
            try {
              const d = new Date(timeStr);
              if (isNaN(d.getTime())) {
                return timeStr; // Return original if invalid
              }

              // Format to 12-hour time with AM/PM
              let hours = d.getHours();
              const minutes = d.getMinutes().toString().padStart(2, "0");
              const ampm = hours >= 12 ? "PM" : "AM";

              hours = hours % 12;
              hours = hours ? hours : 12;

              return `${hours}:${minutes} ${ampm}`;
            } catch (error) {
              return timeStr; // Return original on error
            }
          },



          isReadyToMarkOut(stu) {
            // Student is ready if they have a hold notice (requested) and no one of their gender is currently out
            if (!stu.holdNotice || stu.outTime) {
              return false; // Not requested or already out
            }

            // Check if anyone of the same gender is currently out (has outTime but no backTime)
            const studentsOfSameGender = this.students.filter(
              (s) => s.gender === stu.gender,
            );
            const anyoneOut = studentsOfSameGender.some(
              (s) => s.outTime && !s.backTime,
            );

            // Ready if no one of their gender is currently out
            return !anyoneOut;
          },

          getButtonText(stu) {
            // If student already completed their trip (has both out and back times)
            if (stu.outTime && stu.backTime) {
              return "ALREADY WENT";
            }

            // If student has no hold notice and no out time, show regular request button
            if (!stu.holdNotice && !stu.outTime) {
              return "REQUEST RR";
            }

            // If student is currently out (has out time but no back time)
            if (stu.outTime && !stu.backTime) {
              return "CURRENTLY OUT";
            }

            // If student has requested restroom access
            if (this.isReadyToMarkOut(stu)) {
              // Restroom is available for this gender
              return "RR AVAILABLE";
            } else {
              // Restroom is occupied by someone of the same gender
              return "WAITING";
            }
          },

          getButtonClass(stu) {
            let baseClass = "";

            // Determine base button state
            if (stu.outTime && stu.backTime) {
              baseClass = "already-went";
            } else if (stu.outTime && !stu.backTime) {
              baseClass = "currently-out";
            } else if (this.isReadyToMarkOut(stu)) {
              baseClass = "rr-available";
            } else if (stu.holdNotice && !this.isReadyToMarkOut(stu)) {
              baseClass = "waiting";
            } else if (!stu.outTime && !stu.holdNotice) {
              baseClass = ""; // Default styling
            } else {
              baseClass = "disabled";
            }

            return baseClass;
          },

          getButtonTitle(stu) {
            const buttonText = this.getButtonText(stu);
            let baseTitle = "";

            if (buttonText === "RR AVAILABLE") {
              baseTitle = "SEND NOW";
            } else {
              baseTitle = `Student status - outTime: ${stu.outTime} | holdNotice: ${stu.holdNotice} | ready to promote: ${this.isReadyToMarkOut(stu)}`;
            }

            return baseTitle;
          },

          getBackButtonText(stu) {
            if (stu.outTime && stu.backTime) {
              return "ALREADY WENT";
            }
            return "BACK";
          },

          getBackButtonTitle(stu) {
            if (stu.outTime && stu.backTime) {
              return "Student has already completed their restroom visit";
            }
            if (stu.outTime && !stu.backTime) {
              return "Click to mark student as returned from restroom";
            }
            return "Back button hidden - student must be marked out first";
          },

          onGenderChange(stu) {
            // Track user activity and update gender on the server
            this.recordUserAction();
            console.log("Gender changed for", stu.name, "to", stu.gender);
          },

          onTeacherChange(stu) {
            // Track user activity and update teacher on the server
            this.recordUserAction();
            console.log("Teacher changed for", stu.name, "to", stu.teacher);
          },

          markOut(stu) {
            console.log("markOut button clicked for:", stu.name);

            // Prevent action if student already went (has both out and back times) or is currently out
            if (
              (stu.outTime && stu.backTime) ||
              (stu.outTime && !stu.backTime)
            ) {
              console.log(
                "Student already went or is currently out, ignoring click",
              );
              return;
            }

            // Prevent action if student is waiting but not ready
            if (stu.holdNotice && !this.isReadyToMarkOut(stu)) {
              console.log("Student is waiting but not ready, ignoring click");
              return;
            }

            // Check if there's already a pending update for this student
            if (this.optimisticUI.hasPendingUpdates(stu.name)) {
              console.log("Student already has pending update, ignoring click");
              return;
            }

            this.recordUserAction(); // Track user activity
            console.log("Full student object:", stu);

            // Validate that gender is selected
            if (!stu.gender || stu.gender.trim() === "") {
              console.log("Gender validation failed - showing alert");
              alert(
                "Please select G or B (Gender) before marking the student out.",
              );
              return;
            }

            // If teacher is not selected, auto-assign the detected teacher
            if (
              !stu.teacher ||
              stu.teacher.trim() === "" ||
              stu.teacher === "Select Teacher"
            ) {
              console.log(
                "Teacher not selected, auto-assigning detected teacher:",
                this.detectedTeacher,
              );
              stu.teacher =
                this.detectedTeacher || this.teachers[0] || "Other Teacher";
            }

            // Validate that teacher is now selected
            if (!stu.teacher || stu.teacher.trim() === "") {
              console.log("Teacher validation failed - showing alert");
              alert("Please select a teacher before marking the student out.");
              return;
            }

            console.log("Validations passed. Applying optimistic update for:", {
              studentName: stu.name,
              action: "out",
              teacherName: stu.teacher,
              gender: stu.gender,
            });

            // Apply optimistic update for immediate feedback
            const updateId =
              this.optimisticUI.updateStudentStatusOptimistically(
                stu,
                "out",
                stu.teacher,
                (optimisticState) => {
                  // Update the student object immediately
                  const studentIndex = this.students.findIndex(
                    (s) => s.name === stu.name,
                  );
                  if (studentIndex !== -1) {
                    this.students[studentIndex] = {
                      ...this.students[studentIndex],
                      ...optimisticState,
                    };


                  }
                },
              );

            // Track update start time for performance monitoring
            const updateStartTime = Date.now();

            // Send request to server using optimized endpoint
            google.script.run
              .withSuccessHandler((resp) => {
                const updateTime = Date.now() - updateStartTime;
                console.log("Mark out successful:", resp);
                console.log(`📊 Update response time: ${updateTime}ms`);

                // Validate update performance target (1 second)
                if (updateTime <= 1000) {
                  console.log(
                    `✅ Update performance target met: ${updateTime}ms (target: 1000ms)`,
                  );
                } else {
                  console.warn(
                    `⚠️ Update performance target missed: ${updateTime}ms (target: 1000ms)`,
                  );
                }

                if (resp && resp.success) {
                  // Confirm optimistic update with server response
                  this.optimisticUI.confirmServerUpdate(
                    updateId,
                    resp,
                    (serverState) => {
                      console.log(
                        "Mark out confirmed, triggering immediate data sync",
                      );
                      // Trigger immediate background refresh and smart polling check
                      setTimeout(() => {
                        this._fetchStudentDataInBackground();
                        // Also trigger immediate smart polling check for other potential updates
                        if (this.smartPolling && this.smartPolling.isActive) {
                          this.smartPolling.checkForUpdates();
                        }
                      }, 100); // Small delay to ensure server-side processing is complete
                    },
                  );
                } else {
                  // Handle server-side failure
                  const errorMsg = resp ? resp.error : "Unknown server error";
                  console.error("Server returned failure:", errorMsg);

                  this.optimisticUI.revertOnError(
                    updateId,
                    (originalState) => {
                      // Revert the student object
                      const studentIndex = this.students.findIndex(
                        (s) => s.name === stu.name,
                      );
                      if (studentIndex !== -1) {
                        this.students[studentIndex] = {
                          ...this.students[studentIndex],
                          ...originalState,
                        };

                        // Restore to queue if they were originally waiting
                        if (
                          originalState.holdNotice &&
                          !originalState.outTime
                        ) {

                        }
                      }
                    },
                    errorMsg,
                  );

                  alert(
                    `Error marking student out: ${errorMsg}\n\nThe change has been reverted.`,
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error(
                  "Optimized endpoint failed for marking out:",
                  error,
                );
                console.log("Attempting fallback method...");

                // Try fallback method before reverting
                this._fallbackUpdateStatus(
                  stu.name,
                  "out",
                  stu.teacher,
                  stu.gender,
                  updateId,
                );
              })
              .api_updateStatus(
                stu.name,
                "out",
                stu.teacher,
                stu.gender,
              );
          },

          markBack(stu) {
            console.log("markBack button clicked for:", stu.name);

            // Check if there's already a pending update for this student
            if (this.optimisticUI.hasPendingUpdates(stu.name)) {
              console.log("Student already has pending update, ignoring click");
              return;
            }

            this.recordUserAction(); // Track user activity
            console.log("Student data:", stu);
            console.log("Applying optimistic update for back action:", {
              name: stu.name,
              action: "back",
              teacher: stu.teacher,
              gender: stu.gender,
            });

            // Apply optimistic update for immediate feedback
            const updateId =
              this.optimisticUI.updateStudentStatusOptimistically(
                stu,
                "back",
                stu.teacher,
                (optimisticState) => {
                  // Update the student object immediately
                  const studentIndex = this.students.findIndex(
                    (s) => s.name === stu.name,
                  );
                  if (studentIndex !== -1) {
                    this.students[studentIndex] = {
                      ...this.students[studentIndex],
                      ...optimisticState,
                    };
                  }
                },
              );

            // Track update start time for performance monitoring
            const updateStartTime = Date.now();

            // Send request to server using optimized endpoint
            google.script.run
              .withSuccessHandler((resp) => {
                const updateTime = Date.now() - updateStartTime;
                console.log("Mark back successful:", resp);
                console.log(`📊 Update response time: ${updateTime}ms`);

                // Validate update performance target (1 second)
                if (updateTime <= 1000) {
                  console.log(
                    `✅ Update performance target met: ${updateTime}ms (target: 1000ms)`,
                  );
                } else {
                  console.warn(
                    `⚠️ Update performance target missed: ${updateTime}ms (target: 1000ms)`,
                  );
                }

                if (resp && resp.success) {
                  // Confirm optimistic update with server response
                  this.optimisticUI.confirmServerUpdate(
                    updateId,
                    resp,
                    (serverState) => {
                      console.log(
                        "Mark back confirmed, triggering immediate data sync",
                      );
                      // Trigger immediate background refresh and smart polling check
                      setTimeout(() => {
                        this._fetchStudentDataInBackground();
                        // Also trigger immediate smart polling check for other potential updates
                        if (this.smartPolling && this.smartPolling.isActive) {
                          this.smartPolling.checkForUpdates();
                        }
                      }, 100); // Small delay to ensure server-side processing is complete
                    },
                  );
                } else {
                  // Handle server-side failure
                  const errorMsg = resp ? resp.error : "Unknown server error";
                  console.error("Server returned failure:", errorMsg);

                  this.optimisticUI.revertOnError(
                    updateId,
                    (originalState) => {
                      // Revert the student object
                      const studentIndex = this.students.findIndex(
                        (s) => s.name === stu.name,
                      );
                      if (studentIndex !== -1) {
                        this.students[studentIndex] = {
                          ...this.students[studentIndex],
                          ...originalState,
                        };
                      }
                    },
                    errorMsg,
                  );

                  alert(
                    `Error marking student back: ${errorMsg}\n\nThe change has been reverted.`,
                  );
                }
              })
              .withFailureHandler((error) => {
                console.error(
                  "Optimized endpoint failed for marking back:",
                  error,
                );
                console.log("Attempting fallback method...");

                // Try fallback method before reverting
                this._fallbackUpdateStatus(
                  stu.name,
                  "back",
                  stu.teacher,
                  stu.gender,
                  updateId,
                );
              })
              .api_updateStatus(
                stu.name,
                "back",
                stu.teacher,
                stu.gender,
              );
          },

          // ===== SEARCH FUNCTIONALITY =====

          /**
           * Load all students for dropdown (called on focus)
           */
          showAllStudents() {
            // If we haven't loaded students yet, load them
            if (!this.studentsLoaded) {
              this.loadAllStudents();
            } else {
              // Show all students if no search term
              if (!this.searchTerm || this.searchTerm.trim() === '') {
                this.searchResults = [...this.allStudents];
              } else {
                this.filterStudents();
              }
              this.showSearchResults = true;
              this.highlightedIndex = -1;
            }
          },

          /**
           * Load all students from the server
           */
          loadAllStudents() {
            this.isSearching = true;
            
            google.script.run
              .withSuccessHandler((response) => {
                this.isSearching = false;
                
                if (response && response.success) {
                  this.allStudents = response.students || [];
                  this.studentsLoaded = true;
                  this.searchResults = [...this.allStudents];
                  this.showSearchResults = true;
                  console.log(`Loaded ${this.allStudents.length} students for dropdown`);
                } else {
                  console.error('Failed to load students:', response?.error);
                  this.searchResults = [];
                  this.showSearchResults = false;
                }
              })
              .withFailureHandler((error) => {
                this.isSearching = false;
                console.error('API call failed to load students:', error);
                this.searchResults = [];
                this.showSearchResults = false;
              })
              .api_getAllStudents();
          },

          /**
           * Filter students based on search term (client-side filtering)
           */
          filterStudents() {
            if (!this.studentsLoaded) {
              this.showAllStudents();
              return;
            }

            const searchTerm = this.searchTerm.trim().toLowerCase();
            
            if (!searchTerm) {
              // Show all students if no search term
              this.searchResults = [...this.allStudents];
            } else {
              // Filter students client-side
              this.searchResults = this.allStudents.filter(student => {
                const fullName = student.name.toLowerCase();
                const nameParts = fullName.split(' ');
                
                // Check if search term matches:
                // 1. Start of full name
                // 2. Start of first name  
                // 3. Start of last name
                // 4. Anywhere in full name (for partial matches)
                return fullName.startsWith(searchTerm) ||
                       nameParts.some(part => part.startsWith(searchTerm)) ||
                       fullName.includes(searchTerm);
              });

              // Sort results by relevance (exact matches first, then partial)
              this.searchResults.sort((a, b) => {
                const aName = a.name.toLowerCase();
                const bName = b.name.toLowerCase();
                
                // Exact start matches first
                const aStartsWithSearch = aName.startsWith(searchTerm);
                const bStartsWithSearch = bName.startsWith(searchTerm);
                
                if (aStartsWithSearch && !bStartsWithSearch) return -1;
                if (!aStartsWithSearch && bStartsWithSearch) return 1;
                
                // Then alphabetical
                return aName.localeCompare(bName);
              });
            }
            
            this.showSearchResults = true;
            this.highlightedIndex = -1; // Reset highlight when filtering
            console.log(`Filtered to ${this.searchResults.length} students`);
          },

          /**
           * Select a student from search results
           */
          selectStudent(student) {
            console.log('Selected student:', student);
            
            // Hide search results and clear search
            this.showSearchResults = false;
            this.searchTerm = "";
            this.searchResults = [];

            // Check if student is already in active list
            const existingStudent = this.students.find(s => s.name === student.name);
            if (existingStudent) {
              alert(`${student.name} is already in the active management list.`);
              return;
            }

            // Add student to active list with default values
            const newStudent = {
              name: student.name,
              id: student.id,
              nameId: student.name,
              gender: "",
              teacher: this.detectedTeacher || "",
              outTime: "",
              backTime: "",
              holdNotice: ""
            };

            this.students.push(newStudent);
            console.log(`Added ${student.name} to active management`);

            // Show success feedback
            const successMessage = document.createElement('div');
            successMessage.textContent = `✓ ${student.name} added to active management`;
            successMessage.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: #4caf50;
              color: white;
              padding: 12px 20px;
              border-radius: 4px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.2);
              z-index: 10000;
              font-weight: 500;
            `;
            document.body.appendChild(successMessage);
            
            setTimeout(() => {
              successMessage.remove();
            }, 3000);

            // Scroll to the table so user can see the new student
            setTimeout(() => {
              const table = document.querySelector('.table-container');
              if (table) {
                table.scrollIntoView({ behavior: 'smooth' });
              }
            }, 100);
          },

          /**
           * Remove a student from active management
           */
          removeStudent(student) {
            if (confirm(`Remove ${student.name} from active management?`)) {
              const index = this.students.findIndex(s => s.name === student.name);
              if (index !== -1) {
                this.students.splice(index, 1);
                console.log(`Removed ${student.name} from active management`);
              }
            }
          },

          /**
           * Hide search results when clicking outside
           */
          hideSearchResults() {
            setTimeout(() => {
              this.showSearchResults = false;
              this.highlightedIndex = -1;
            }, 200); // Small delay to allow click events to fire
          },

          /**
           * Keyboard navigation - highlight next item
           */
          highlightNext() {
            if (this.searchResults.length === 0) return;
            this.highlightedIndex = Math.min(this.highlightedIndex + 1, this.searchResults.length - 1);
          },

          /**
           * Keyboard navigation - highlight previous item
           */
          highlightPrevious() {
            if (this.searchResults.length === 0) return;
            this.highlightedIndex = Math.max(this.highlightedIndex - 1, -1);
          },

          /**
           * Keyboard navigation - select highlighted item
           */
          selectHighlighted() {
            if (this.highlightedIndex >= 0 && this.highlightedIndex < this.searchResults.length) {
              this.selectStudent(this.searchResults[this.highlightedIndex]);
            }
          },

        };
      }
    </script>

    <!-- Alpine.js - loaded after appData function is defined -->
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  </body>
</html>
