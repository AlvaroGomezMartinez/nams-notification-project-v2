<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>NAMS Restroom Sign-Out</title>
  <!-- Import Material Icons (keeping just the icons) -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    /* Reset and base styles */
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      margin: -10px;
    }

    .col {
      padding: 10px;
    }

    .col.s8 {
      flex: 0 0 66.666%;
    }

    .col.s4 {
      flex: 0 0 33.333%;
    }

    .col.s12 {
      flex: 0 0 100%;
    }

    /* Card styles */
    .card-panel {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 15px;
    }

    .teal.lighten-4 {
      background-color: #b2dfdb !important;
    }

    .blue {
      background-color: #292f61 !important;
    }

    .white-text {
      color: white !important;
    }

    /* Button styles */
    .btn {
      display: inline-block;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      text-decoration: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .btn:hover:not(.disabled):not(.currently-out):not(.waiting):not(.already-went) {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    /* Form styles */
    select.browser-default {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      font-size: 14px;
    }

    /* Table styles */
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    table.striped tbody tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    th,
    td {
      padding: 12px 8px;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    th {
      background-color: #f5f5f5;
      font-weight: 600;
      text-align: center !important;
      padding: 12px 8px;
      border-bottom: 1px solid #e0e0e0;
    }

    /* Modern Spinner CSS Custom Properties */
    :root {
      --spinner-primary-color: #2196f3;
      --spinner-secondary-color: rgba(33, 150, 243, 0.3);
      --spinner-size: 12px;
      --spinner-spacing: 8px;
      --spinner-duration: 1.2s;
    }

    /* Modern Pulsing Dots Spinner */
    .modern-spinner {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spinner-spacing);
    }

    .modern-spinner .dot {
      width: var(--spinner-size);
      height: var(--spinner-size);
      background-color: var(--spinner-primary-color);
      border-radius: 50%;
      animation: pulse-dot var(--spinner-duration) ease-in-out infinite;
      will-change: transform, opacity;
    }

    .modern-spinner .dot:nth-child(1) {
      animation-delay: 0s;
    }

    .modern-spinner .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .modern-spinner .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    /* Pulsing Animation Keyframes */
    @keyframes pulse-dot {

      0%,
      100% {
        transform: scale(0.8);
        opacity: 0.3;
      }

      50% {
        transform: scale(1.2);
        opacity: 1;
      }
    }

    .highlight {
      background-color: #ffff99;
      /* light yellow highlight */
    }

    .hold-text {
      color: red;
    }

    .out-btn {
      background-color: #1976d2;
      /* blue instead of amber */
      color: white;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .out-btn.disabled {
      background-color: #9e9e9e !important;
      /* grey when disabled */
      color: #ffffff !important;
      pointer-events: none;
      opacity: 0.6;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .out-btn.waiting {
      background-color: #424242 !important;
      /* darker grey for WAITING */
      color: #ffffff !important;
      pointer-events: none;
      opacity: 0.8;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .out-btn.already-went {
      background-color: #757575 !important;
      /* grey for ALREADY WENT */
      color: #ffffff !important;
      pointer-events: none;
      opacity: 0.6;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Enhanced button states for new behavior */
    .out-btn.currently-out {
      background-color: #ff000e !important;
      /* red for CURRENTLY OUT */
      color: #ffffff !important;
      /* white text for better contrast on red */
      pointer-events: none;
      opacity: 1;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .out-btn.rr-available {
      background-color: #4caf50 !important;
      /* green for RR AVAILABLE */
      color: #ffffff !important;
      pointer-events: auto;
      opacity: 1;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .out-btn.rr-available:hover {
      background-color: #45a049 !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
    }

    .back-btn {
      background-color: #43a047;
      /* green */
      color: white;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .back-btn.active {
      background-color: #93c37e !important;
      /* green when student is out and needs to come back */
      color: #000000 !important;
    }

    .back-btn.disabled {
      background-color: #9e9e9e !important;
      /* grey when disabled */
      color: #ffffff !important;
      pointer-events: none;
      opacity: 0.6;
    }

    .back-btn.already-went {
      background-color: #757575 !important;
      /* grey for ALREADY WENT */
      color: #ffffff !important;
      pointer-events: none;
      opacity: 0.6;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Enhanced button state transitions and animations */
    .out-btn,
    .back-btn {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: background-color, color, transform, box-shadow, opacity;
    }

    /* Smooth color transitions for all button states */
    .out-btn:not(.disabled):not(.currently-out):not(.waiting):not(.already-went):hover {
      background-color: #1565c0 !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(25, 118, 210, 0.3);
    }

    /* Focus states for accessibility */
    .btn:focus {
      outline: 2px solid #2196f3;
      outline-offset: 2px;
    }

    .out-btn.currently-out:focus,
    .out-btn.waiting:focus,
    .out-btn.disabled:focus,
    .out-btn.already-went:focus {
      outline: none;
      /* Remove focus outline for non-interactive states */
    }

    /* Animation for button state changes */
    @keyframes buttonStateChange {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    .btn.state-changing {
      animation: buttonStateChange 0.3s ease-in-out;
    }

    /* Back button visibility states */
    .back-btn.hidden {
      visibility: hidden;
      opacity: 0;
      transition:
        visibility 0s 0.3s,
        opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform: scale(0.95);
    }

    .back-btn.visible {
      visibility: visible;
      opacity: 1;
      transition:
        visibility 0s,
        opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
        transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform: scale(1);
    }

    /* Enhanced Back button active state */
    .back-btn.active:hover {
      background-color: #fdfd00 !important;
      transform: translateY(-1px) scale(1);
      box-shadow: 0 4px 8px rgba(211, 47, 47, 0.3);
    }

    .table-container {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 70vh;
      padding: 15px !important;
      background-color: #f8f9fa !important;
      margin-bottom: 10px !important;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
    }



    /* Regular header styles with tight spacing (no longer sticky) */
    .sticky-header {
      background-color: white;
      padding: 10px 0;
      border-bottom: 2px solid #e0e0e0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      line-height: 1.2;
    }

    .sticky-header h4,
    .sticky-header h5,
    .sticky-header h6 {
      margin: 0 0 5px 0;
      line-height: 1.2;
    }

    .sticky-header small {
      margin-bottom: 5px !important;
    }

    /* Loading state styles */
    .loading-blur {
      filter: blur(1px);
      opacity: 0.5;
      pointer-events: none;
    }

    .loading-overlay {
      border-radius: 4px;
    }

    /* Center table headers */
    th,
    .table-container thead th {
      text-align: center !important;
      background: #f5f5f5;
      font-weight: 600;
    }

    /* Center specific table data columns */
    .table-container tbody td:nth-child(2),
    /* Gender column */
    .table-container tbody td:nth-child(6),
    /* Return Status column */
    .table-container tbody td:nth-child(7),
    /* Back Time column */
    .table-container tbody td:nth-child(8)

    /* Remove column */
      {
      text-align: center;
    }

    /* Keep student name and teacher columns left-aligned for readability */
    .table-container tbody td:nth-child(1),
    /* Student Name column */
    /* Gender column */
    .table-container tbody td:nth-child(2),
    /* Teacher column */
    .table-container tbody td:nth-child(3),
    /* Request Status column */
    .table-container tbody td:nth-child(4),
    /* Out Time column */
    .table-container tbody td:nth-child(5) {
      text-align: left;
    }
  </style>
</head>

<body>
  <div class="container" x-data="appData()" x-init="init()" @click.away="hideSearchResults()">
    <!-- Sticky header with date, period, and teacher info -->
    <div class="sticky-header">
      <h1>Northside Alternative MS</h1>
      <H3>Student Restroom Log</H3>
      <h5 x-text="dateString"></h5>
      <h5 x-text="'Current Period: ' + periodString"></h5>
      <small x-text="nextPeriodString" style="
            color: #292f60;
            font-style: italic;
            display: block;
            margin-bottom: 5px;
          "></small>


      <!-- Auto-detected teacher info -->
      <div class="row" x-show="detectedTeacher">
        <div class="col s12">
          <div class="card-panel blue" style="padding: 10px">
            <span class="white-text">
              <i class="material-icons tiny" style="vertical-align: text-bottom">person</i>
              Hello, <strong x-text="detectedTeacher"></strong>
              <small x-show="userEmail">(logged in as: <span x-text="userEmail"></span>)</small>
            </span>
          </div>
        </div>
      </div>
    </div>

    <!-- Student Search Section -->
    <div class="row">
      <div class="col s12">
        <h3 style="margin-top: 0">ADD STUDENT</h3>
        <div class="card-panel" style="padding: 15px">

          <!-- Search Input -->
          <div style="position: relative; margin-bottom: 15px">
            <input type="text" x-model="searchTerm" @input="filterStudents()" @focus="showAllStudents()"
              @keydown.escape="hideSearchResults()" @keydown.arrow-down.prevent="highlightNext()"
              @keydown.arrow-up.prevent="highlightPrevious()" @keydown.enter.prevent="selectHighlighted()"
              placeholder="Click to see all students or type to search..." style="
                  width: 100%; 
                  padding: 12px; 
                  border: 2px solid #ddd; 
                  border-radius: 4px; 
                  font-size: 16px;
                  box-sizing: border-box;
                " />

            <!-- Search Results Dropdown -->
            <div x-show="showSearchResults && (searchResults.length > 0 || isSearching)" style="
                  position: absolute;
                  top: 100%;
                  left: 0;
                  right: 0;
                  background: white;
                  border: 1px solid #ddd;
                  border-top: none;
                  border-radius: 0 0 4px 4px;
                  max-height: 300px;
                  overflow-y: auto;
                  z-index: 1000;
                  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                ">
              <!-- Loading state -->
              <div x-show="isSearching" style="padding: 15px; text-align: center; color: #666;">
                <div class="modern-spinner" style="justify-content: center; margin-bottom: 8px;">
                  <div class="dot"></div>
                  <div class="dot"></div>
                  <div class="dot"></div>
                </div>
                Loading students...
              </div>

              <!-- Results count header -->
              <div x-show="!isSearching && searchResults.length > 0" style="
                       padding: 8px 12px; 
                       background: #f8f9fa; 
                       border-bottom: 1px solid #e9ecef; 
                       font-size: 12px; 
                       color: #666;
                       font-weight: 500;
                     ">
                <span x-show="!searchTerm || searchTerm.trim() === ''"
                  x-text="`All Students (${searchResults.length})`"></span>
                <span x-show="searchTerm && searchTerm.trim() !== ''"
                  x-text="`${searchResults.length} students found`"></span>
              </div>

              <!-- Student list -->
              <template x-for="(student, index) in searchResults" :key="student.id || index">
                <div @click="selectStudent(student)" @mouseenter="highlightedIndex = index"
                  :class="{ 'highlighted': index === highlightedIndex }" style="
                      padding: 12px;
                      cursor: pointer;
                      border-bottom: 1px solid #f0f0f0;
                      transition: background-color 0.2s ease;
                    " :style="{ 
                      'background-color': index === highlightedIndex ? '#e3f2fd' : 'white',
                      'border-left': index === highlightedIndex ? '3px solid #2196f3' : '3px solid transparent'
                    }">
                  <div style="font-weight: 500; color: #333;" x-text="student.name"></div>
                  <div x-show="student.id" style="font-size: 12px; color: #666; margin-top: 2px;">
                    ID: <span x-text="student.id"></span>
                  </div>
                </div>
              </template>

              <!-- No results message -->
              <div x-show="!isSearching && searchResults.length === 0 && searchTerm && searchTerm.trim() !== ''"
                style="padding: 20px; text-align: center; color: #666; font-style: italic;">
                No students found matching "<span x-text="searchTerm"></span>"
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Active Students Table -->
    <div class="row">
      <!-- Active Students table column -->
      <div class="col s12">
        <h3>RESTROOM LIST</h3>

        <!-- Refresh controls -->
        <div class="row" style="margin-bottom: 10px">
          <div class="col s3">
            <div class="card-panel" style="padding: 10px">
              <button class="btn" @click="manualRefresh()" style="margin-right: 10px">
                <i class="material-icons left">refresh</i>Refresh Data
              </button>
            </div>
          </div>
        </div>

        <div class="table-container" style="position: relative">
          <!-- Loading Spinner Overlay -->
          <div x-show="isLoading" class="loading-overlay" style="
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(255, 255, 255, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                z-index: 10;
                min-height: 200px;
              ">
            <div class="modern-spinner">
              <div class="dot"></div>
              <div class="dot"></div>
              <div class="dot"></div>
            </div>
            <p style="margin-top: 15px; color: #666; font-weight: 500">
              <span x-text="loadingMessage || 'Loading student data...'"></span>
            </p>
          </div>

          <!-- No Active Students Message -->
          <div x-show="!isLoading && students.length === 0" style="text-align: center; padding: 40px; color: #666;">
            <i class="material-icons" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;">event_seat</i>
            <h6>No students are currently using the restroom</h6>
          </div>

          <!-- Active Students Table -->
          <table x-show="students.length > 0" class="striped" :class="{ 'loading-blur': isLoading }">
            <thead>
              <tr>
                <th>Student Name</th>
                <th>G or B</th>
                <th>Teacher</th>
                <th>RR Status</th>
                <th>Out</th>
                <th>Return</th>
                <th>Back</th>
                <th>Remove</th>
              </tr>
            </thead>
            <tbody>
              <template x-for="stu in students" :key="stu.nameId || stu.name">
                <tr :class="{ highlight: isReadyToMarkOut(stu) }">
                  <td>
                    <span x-text="stu.name"></span>
                    <span x-show="stu.holdNotice && !stu.outTime && getQueuePosition(stu)"
                      style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 10px; font-size: 11px; margin-left: 8px;">
                      #<span x-text="getQueuePosition(stu)"></span>
                    </span>

                  </td>
                  <td>
                    <select x-model="stu.gender" @change="onGenderChange(stu)" class="browser-default">
                      <option value=""></option>
                      <option value="G">G</option>
                      <option value="B">B</option>
                    </select>
                  </td>
                  <td>
                    <select x-model="stu.teacher" @change="onTeacherChange(stu)" class="browser-default">
                      <option value="">Select Teacher</option>
                      <template x-for="t in teachers" :key="t">
                        <option x-text="t" :value="t"></option>
                      </template>
                    </select>
                  </td>
                  <td>
                    <button class="btn out-btn" :class="getButtonClass(stu)" @click="markOut(stu)"
                      :title="getButtonTitle(stu)">
                      <span x-text="getButtonText(stu)"></span>
                    </button>
                  </td>
                  <td>
                    <span x-text="formatTime(stu.outTime)"></span>
                  </td>
                  <td>
                    <button class="btn back-btn" :class="{ 
                            'hidden': !stu.outTime || stu.backTime,
                            'visible': stu.outTime && !stu.backTime,
                            'active': stu.outTime && !stu.backTime,
                            'already-went': stu.outTime && stu.backTime
                          }" @click="markBack(stu)" :title="getBackButtonTitle(stu)">
                      <span x-text="getBackButtonText(stu)"></span>
                    </button>
                  </td>
                  <td>
                    <span x-text="formatTime(stu.backTime)"></span>
                  </td>
                  <td>
                    <button class="btn" :style="getRemoveButtonStyle(stu)" @click="handleRemoveClick(stu)"
                      :title="getRemoveButtonTitle(stu)">
                      <i class="material-icons" style="font-size: 16px;" x-text="getRemoveButtonIcon(stu)"></i>
                    </button>
                  </td>
                </tr>
              </template>
            </tbody>
          </table>
        </div>
      </div>


    </div>
  </div>

  <script>
    // Global test functions for debugging (accessible from browser console)
    window.testUsageLimit = function (studentName) {
      console.log('Testing usage limit for:', studentName);

      google.script.run
        .withSuccessHandler((result) => {
          console.log('Test usage limit result:', result);
          alert(`Usage check result: ${JSON.stringify(result, null, 2)}`);
        })
        .withFailureHandler((error) => {
          console.error('Test usage limit error:', error);
          alert(`Error: ${error.message || error}`);
        })
        .api_checkStudentUsageLimit(studentName);
    };

    window.debugStudentSelection = function (studentName) {
      console.log('Debugging student selection for:', studentName);

      google.script.run
        .withSuccessHandler((result) => {
          console.log('Debug student selection result:', result);
          alert(`Debug result: ${JSON.stringify(result, null, 2)}`);
        })
        .withFailureHandler((error) => {
          console.error('Debug student selection error:', error);
          alert(`Error: ${error.message || error}`);
        })
        .api_debugStudentSelection(studentName);
    };

    window.getTodaysLogEntries = function (studentName) {
      console.log('Getting today\'s log entries for:', studentName || 'all students');

      google.script.run
        .withSuccessHandler((result) => {
          console.log('Today\'s log entries result:', result);
          alert(`Log entries: ${JSON.stringify(result, null, 2)}`);
        })
        .withFailureHandler((error) => {
          console.error('Get log entries error:', error);
          alert(`Error: ${error.message || error}`);
        })
        .api_getTodaysLogEntries(studentName);
    };

    /**
     * SmartPollingManager for adaptive refresh based on user activity
     * Adjusts polling frequency based on user interaction patterns
     */
    class SmartPollingManager {
      constructor() {
        this.isActive = false;
        this.currentInterval = null;
        this.isCheckingForUpdates = false; // Prevent concurrent update checks
        this.baseIntervalMs = 60000; // 1 minute base interval
        this.activeIntervalMs = 30000; // 30 seconds when active
        this.inactiveIntervalMs = 120000; // 2 minutes when inactive
        this.maxIntervalMs = 300000; // 5 minutes maximum

        this.lastUserActivity = Date.now();
        this.lastUpdateCheck = 0;
        this.lastUpdateTimestamp = 0;
        this.consecutiveNoChanges = 0;
        this.maxConsecutiveNoChanges = 5;

        this.activityThresholds = {
          active: 60000, // 1 minute since last activity = active
          inactive: 300000, // 5 minutes since last activity = inactive
          dormant: 900000, // 15 minutes since last activity = dormant
        };

        this.callbacks = {
          onUpdate: null,
          onActivityChange: null,
        };

        this.stats = {
          totalChecks: 0,
          updatesFound: 0,
          lastUpdateTime: null,
          averageInterval: this.baseIntervalMs,
        };
      }

      /**
       * Start adaptive polling with callbacks
       * @param {Function} updateCallback - Function to call when updates are needed
       * @param {Function} activityCallback - Function to call when activity level changes
       */
      startAdaptivePolling(updateCallback, activityCallback = null) {
        console.log("SmartPollingManager: Starting adaptive polling");

        this.callbacks.onUpdate = updateCallback;
        this.callbacks.onActivityChange = activityCallback;
        this.isActive = true;
        this.lastUserActivity = Date.now();

        // Start with base interval
        this._scheduleNextCheck(this.baseIntervalMs);

        // Set up activity monitoring
        this._setupActivityMonitoring();

        console.log(
          `SmartPollingManager: Started with ${this.baseIntervalMs}ms base interval`,
        );
      }

      /**
       * Stop adaptive polling
       */
      stopPolling() {
        console.log("SmartPollingManager: Stopping adaptive polling");

        if (this.currentInterval) {
          clearTimeout(this.currentInterval);
          this.currentInterval = null;
        }

        this.isActive = false;
        this.isCheckingForUpdates = false; // Clear any pending check flag
        this._cleanupActivityMonitoring();
      }

      /**
       * Record user activity to adjust polling frequency
       */
      recordUserActivity() {
        const now = Date.now();
        const wasActive = this._isUserActive();

        this.lastUserActivity = now;

        // Check if activity level changed
        const isNowActive = this._isUserActive();
        if (wasActive !== isNowActive && this.callbacks.onActivityChange) {
          this.callbacks.onActivityChange(
            isNowActive ? "active" : "inactive",
          );
        }

        // If we were in a long interval and user became active, reschedule sooner
        if (isNowActive && this.currentInterval) {
          const nextCheckIn = this._getOptimalInterval();
          if (nextCheckIn < this.activeIntervalMs) {
            console.log(
              "SmartPollingManager: User became active, rescheduling check sooner",
            );
            this._scheduleNextCheck(this.activeIntervalMs);
          }
        }
      }

      /**
       * Check for updates using incremental update endpoint
       * @param {number} lastUpdateTimestamp - Timestamp of last known update
       * @returns {Promise} - Promise that resolves with update info
       */
      async checkForUpdates(lastUpdateTimestamp = null) {
        if (!this.isActive) {
          console.log(
            "SmartPollingManager: Not active, skipping update check",
          );
          return null;
        }

        // Prevent concurrent update checks
        if (this.isCheckingForUpdates) {
          console.log(
            "SmartPollingManager: Update check already in progress, skipping",
          );
          return null;
        }

        this.isCheckingForUpdates = true;
        const now = Date.now();
        this.stats.totalChecks++;
        this.lastUpdateCheck = now;

        console.log(
          "SmartPollingManager: Checking for updates using optimized endpoint...",
        );

        return new Promise((resolve, reject) => {
          // Use the optimized incremental update endpoint
          if (
            typeof google !== "undefined" &&
            google.script &&
            google.script.run.api_getStatusUpdatesOptimized
          ) {
            // Simplified polling - just trigger a full refresh
            console.log("SmartPollingManager: Triggering full refresh (no incremental updates)");

            // Always trigger update callback for full refresh
            if (this.callbacks.onUpdate) {
              this.callbacks.onUpdate({
                hasUpdates: true,
                fallback: true,
                fullRefresh: true
              });
            }

            // Schedule next check
            this._scheduleNextCheck();
            this.isCheckingForUpdates = false;
            resolve({
              hasUpdates: true,
              fallback: true,
              fullRefresh: true
            });
          } else {
            // Fallback: just trigger a regular update
            console.log(
              "SmartPollingManager: Optimized endpoint not available, using fallback update method",
            );
            if (this.callbacks.onUpdate) {
              this.callbacks.onUpdate({ hasUpdates: true, fallback: true });
            }
            this._scheduleNextCheck();
            this.isCheckingForUpdates = false; // Clear the flag
            resolve({ hasUpdates: true, fallback: true });
          }
        });
      }

      /**
       * Adjust polling frequency based on current conditions
       * @param {Object} options - Options for frequency adjustment
       */
      adjustPollingFrequency(options = {}) {
        const {
          forceActive = false,
          forceInactive = false,
          customInterval = null,
        } = options;

        let newInterval;

        if (customInterval) {
          newInterval = Math.max(customInterval, 10000); // Minimum 10 seconds
        } else if (forceActive) {
          newInterval = this.activeIntervalMs;
        } else if (forceInactive) {
          newInterval = this.inactiveIntervalMs;
        } else {
          newInterval = this._getOptimalInterval();
        }

        console.log(
          `SmartPollingManager: Adjusting frequency to ${newInterval}ms`,
        );

        // Update average interval for stats
        this.stats.averageInterval =
          (this.stats.averageInterval + newInterval) / 2;

        // Reschedule if currently active
        if (this.isActive && this.currentInterval) {
          this._scheduleNextCheck(newInterval);
        }
      }

      /**
       * Get current polling statistics
       * @returns {Object} - Polling statistics
       */
      getStats() {
        const now = Date.now();
        const activityLevel = this._getActivityLevel();
        const timeSinceLastActivity = now - this.lastUserActivity;
        const timeSinceLastCheck = now - this.lastUpdateCheck;

        return {
          isActive: this.isActive,
          activityLevel: activityLevel,
          timeSinceLastActivity: timeSinceLastActivity,
          timeSinceLastCheck: timeSinceLastCheck,
          totalChecks: this.stats.totalChecks,
          updatesFound: this.stats.updatesFound,
          updateRate:
            this.stats.totalChecks > 0
              ? (
                (this.stats.updatesFound / this.stats.totalChecks) *
                100
              ).toFixed(1) + "%"
              : "0%",
          consecutiveNoChanges: this.consecutiveNoChanges,
          averageInterval: Math.round(this.stats.averageInterval),
          lastUpdateTime: this.stats.lastUpdateTime,
          nextCheckIn: this.currentInterval ? "scheduled" : "not scheduled",
        };
      }

      /**
       * Private method to determine optimal polling interval
       * @returns {number} - Optimal interval in milliseconds
       */
      _getOptimalInterval() {
        const activityLevel = this._getActivityLevel();
        let interval;

        switch (activityLevel) {
          case "active":
            interval = this.activeIntervalMs;
            break;
          case "inactive":
            interval = this.inactiveIntervalMs;
            break;
          case "dormant":
            interval = this.maxIntervalMs;
            break;
          default:
            interval = this.baseIntervalMs;
        }

        // Increase interval if we've had many consecutive no-change checks
        if (this.consecutiveNoChanges >= this.maxConsecutiveNoChanges) {
          interval = Math.min(interval * 2, this.maxIntervalMs);
          console.log(
            `SmartPollingManager: Increasing interval due to ${this.consecutiveNoChanges} consecutive no-change checks`,
          );
        }

        return interval;
      }

      /**
       * Private method to determine current activity level
       * @returns {string} - Activity level: 'active', 'inactive', or 'dormant'
       */
      _getActivityLevel() {
        const timeSinceActivity = Date.now() - this.lastUserActivity;

        if (timeSinceActivity < this.activityThresholds.active) {
          return "active";
        } else if (timeSinceActivity < this.activityThresholds.inactive) {
          return "inactive";
        } else {
          return "dormant";
        }
      }

      /**
       * Private method to check if user is currently active
       * @returns {boolean} - True if user is active
       */
      _isUserActive() {
        return this._getActivityLevel() === "active";
      }

      /**
       * Private method to schedule the next update check
       * @param {number} intervalMs - Interval in milliseconds (optional)
       */
      _scheduleNextCheck(intervalMs = null) {
        if (this.currentInterval) {
          clearTimeout(this.currentInterval);
        }

        const interval = intervalMs || this._getOptimalInterval();

        this.currentInterval = setTimeout(() => {
          if (this.isActive) {
            this.checkForUpdates();
          }
        }, interval);

        console.log(
          `SmartPollingManager: Next check scheduled in ${interval}ms (${Math.round(interval / 1000)}s)`,
        );
      }

      /**
       * Private method to set up activity monitoring
       */
      _setupActivityMonitoring() {
        // Monitor various user interaction events
        const events = [
          "click",
          "keydown",
          "mousemove",
          "scroll",
          "touchstart",
        ];

        this._activityHandler = () => {
          this.recordUserActivity();
        };

        // Throttle activity recording to avoid excessive calls
        this._throttledActivityHandler = this._throttle(
          this._activityHandler,
          5000,
        ); // 5 seconds

        events.forEach((event) => {
          document.addEventListener(event, this._throttledActivityHandler, {
            passive: true,
          });
        });
      }

      /**
       * Private method to clean up activity monitoring
       */
      _cleanupActivityMonitoring() {
        if (this._throttledActivityHandler) {
          const events = [
            "click",
            "keydown",
            "mousemove",
            "scroll",
            "touchstart",
          ];
          events.forEach((event) => {
            document.removeEventListener(
              event,
              this._throttledActivityHandler,
            );
          });
        }
      }

      /**
       * Private method to throttle function calls
       * @param {Function} func - Function to throttle
       * @param {number} limit - Throttle limit in milliseconds
       * @returns {Function} - Throttled function
       */
      _throttle(func, limit) {
        let inThrottle;
        return function () {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      }
    }

    /**
     * OptimisticUI class for immediate user feedback
     * Handles optimistic updates with server confirmation and rollback on errors
     */
    class OptimisticUI {
      constructor(appContext = null) {
        this.pendingUpdates = new Map(); // Track pending optimistic updates
        this.originalStates = new Map(); // Store original states for rollback
        this.appContext = appContext; // Reference to the main app for accessing students array
      }

      /**
       * Update student status optimistically for immediate UI feedback
       * @param {Object} student - Student object to update
       * @param {string} action - Action being performed ('out' or 'back')
       * @param {string} teacherName - Teacher name
       * @param {Function} updateCallback - Callback to update UI immediately
       * @returns {string} - Update ID for tracking
       */
      updateStudentStatusOptimistically(
        student,
        action,
        teacherName,
        updateCallback,
      ) {
        const updateId = `${student.nameId || student.name.replace(/[^a-zA-Z0-9]/g, '_')}_${action}_${Date.now()}`;

        // Store original state for potential rollback
        this.originalStates.set(updateId, {
          outTime: student.outTime,
          backTime: student.backTime,
          holdNotice: student.holdNotice,
        });

        // Create optimistic state
        const optimisticState = { ...student };
        const now = new Date();
        const timeString = this._formatTimeToHHMM(now);

        if (action === "out") {
          // Check if restroom is available for this gender before setting optimistic state
          const studentsOfSameGender = this.appContext ? this.appContext.students.filter(
            (s) => s.gender === student.gender,
          ) : [];
          const anyoneOut = studentsOfSameGender.some(
            (s) => s.outTime && !s.backTime,
          );

          console.log(`OptimisticUI: Checking restroom availability for ${student.name} (${student.gender})`);
          console.log(`OptimisticUI: Students of same gender:`, studentsOfSameGender.map(s => `${s.name} (out: ${s.outTime}, back: ${s.backTime})`));
          console.log(`OptimisticUI: Anyone out?`, anyoneOut);

          if (anyoneOut) {
            // Restroom is occupied - student will be added to waiting list
            let waitingCount = studentsOfSameGender.filter(
              (s) => s.holdNotice && !s.outTime,
            ).length;
            const position = waitingCount + 1;
            optimisticState.holdNotice = `Waiting in line. Position ${position}.`;
            optimisticState.outTime = ""; // No out time yet
            console.log(
              `OptimisticUI: Adding ${student.name} to waiting list optimistically (position ${position})`,
            );
          } else {
            // Restroom is available - student will go out immediately
            optimisticState.outTime = timeString;
            optimisticState.holdNotice = ""; // Clear hold notice when going out
            console.log(
              `OptimisticUI: Marking ${student.name} OUT optimistically at ${timeString}`,
            );
          }
        } else if (action === "back") {
          optimisticState.backTime = timeString;
          console.log(
            `OptimisticUI: Marking ${student.name} BACK optimistically at ${timeString}`,
          );
        }

        // Track this pending update
        this.pendingUpdates.set(updateId, {
          studentName: student.name,
          action: action,
          teacherName: teacherName,
          optimisticState: optimisticState,
          timestamp: Date.now(),
        });

        // Apply optimistic update to UI immediately
        if (updateCallback) {
          updateCallback(optimisticState);
        }

        console.log(`OptimisticUI: Applied optimistic update ${updateId}`);
        return updateId;
      }

      /**
       * Confirm server update and clean up optimistic state
       * @param {string} updateId - Update ID from optimistic update
       * @param {Object} serverState - Confirmed state from server
       * @param {Function} updateCallback - Callback to update UI with server state
       */
      confirmServerUpdate(updateId, serverState, updateCallback) {
        const pendingUpdate = this.pendingUpdates.get(updateId);

        if (!pendingUpdate) {
          console.warn(
            `OptimisticUI: No pending update found for ID ${updateId}`,
          );
          return;
        }

        console.log(`OptimisticUI: Confirming server update ${updateId}`);

        // Merge server state with any additional server-provided data
        if (updateCallback && serverState) {
          updateCallback(serverState);
        }

        // Clean up tracking
        this.pendingUpdates.delete(updateId);
        this.originalStates.delete(updateId);

        console.log(
          `OptimisticUI: Server update confirmed and cleaned up ${updateId}`,
        );
      }

      /**
       * Revert optimistic update on server error
       * @param {string} updateId - Update ID from optimistic update
       * @param {Function} revertCallback - Callback to revert UI to original state
       * @param {string} errorMessage - Error message for logging
       */
      revertOnError(
        updateId,
        revertCallback,
        errorMessage = "Server update failed",
      ) {
        const pendingUpdate = this.pendingUpdates.get(updateId);
        const originalState = this.originalStates.get(updateId);

        if (!pendingUpdate || !originalState) {
          console.warn(
            `OptimisticUI: Cannot revert - no data found for ID ${updateId}`,
          );
          return;
        }

        console.log(
          `OptimisticUI: Reverting optimistic update ${updateId} due to: ${errorMessage}`,
        );

        // Revert to original state
        if (revertCallback) {
          revertCallback(originalState);
        }

        // Clean up tracking
        this.pendingUpdates.delete(updateId);
        this.originalStates.delete(updateId);

        console.log(
          `OptimisticUI: Reverted update ${updateId} to original state`,
        );
      }

      /**
       * Get all pending updates (for debugging or status display)
       * @returns {Array} - Array of pending update info
       */
      getPendingUpdates() {
        return Array.from(this.pendingUpdates.values()).map((update) => ({
          studentName: update.studentName,
          action: update.action,
          timestamp: update.timestamp,
          age: Date.now() - update.timestamp,
        }));
      }

      /**
       * Clean up old pending updates (in case server never responds)
       * @param {number} maxAgeMs - Maximum age in milliseconds (default: 30 seconds)
       */
      cleanupOldUpdates(maxAgeMs = 30000) {
        const now = Date.now();
        const toRemove = [];

        for (const [updateId, update] of this.pendingUpdates.entries()) {
          if (now - update.timestamp > maxAgeMs) {
            toRemove.push(updateId);
          }
        }

        toRemove.forEach((updateId) => {
          console.warn(
            `OptimisticUI: Cleaning up old pending update ${updateId}`,
          );
          this.pendingUpdates.delete(updateId);
          this.originalStates.delete(updateId);
        });

        return toRemove.length;
      }

      /**
       * Check if a student has pending updates
       * @param {string} studentName - Name of student to check
       * @returns {boolean} - True if student has pending updates
       */
      hasPendingUpdates(studentName) {
        for (const update of this.pendingUpdates.values()) {
          if (update.studentName === studentName) {
            return true;
          }
        }
        return false;
      }

      /**
       * Get pending update info for a specific student
       * @param {string} studentName - Name of student
       * @returns {Object|null} - Pending update info or null
       */
      getPendingUpdateForStudent(studentName) {
        for (const [updateId, update] of this.pendingUpdates.entries()) {
          if (update.studentName === studentName) {
            return {
              updateId: updateId,
              action: update.action,
              timestamp: update.timestamp,
              age: Date.now() - update.timestamp,
            };
          }
        }
        return null;
      }

      /**
       * Clear all pending updates (use with caution)
       */
      clearAllPending() {
        const count = this.pendingUpdates.size;
        this.pendingUpdates.clear();
        this.originalStates.clear();
        console.log(`OptimisticUI: Cleared ${count} pending updates`);
        return count;
      }

      /**
       * Private method to format time consistently
       * @param {Date} date - Date object to format
       * @returns {string} - Formatted time string
       */
      _formatTimeToHHMM(date) {
        let hours = date.getHours();
        const minutes = date.getMinutes().toString().padStart(2, "0");
        const ampm = hours >= 12 ? "PM" : "AM";

        hours = hours % 12;
        hours = hours ? hours : 12;

        return `${hours}:${minutes} ${ampm}`;
      }
    }

    /**
     * LocalDataCache class for browser-side caching
     * Implements localStorage-based caching with versioning and expiration
     */
    class LocalDataCache {
      constructor() {
        this.CACHE_PREFIX = "nams_restroom_";
        this.VERSION = "1.0";
        this.DEFAULT_TTL_MINUTES = 60; // 1 hour default
        this.MAX_CACHE_SIZE = 4 * 1024 * 1024; // 4MB limit for localStorage
      }

      /**
       * Store data in localStorage with TTL and versioning
       * @param {string} key - Cache key
       * @param {any} data - Data to cache
       * @param {number} ttlMinutes - Time to live in minutes
       * @returns {boolean} - Success status
       */
      set(key, data, ttlMinutes = this.DEFAULT_TTL_MINUTES) {
        try {
          const cacheEntry = {
            data: data,
            timestamp: Date.now(),
            expiresAt: Date.now() + ttlMinutes * 60 * 1000,
            version: this.VERSION,
          };

          const serializedData = JSON.stringify(cacheEntry);
          const fullKey = this.CACHE_PREFIX + key;

          // Check cache size before storing
          if (this._wouldExceedCacheLimit(serializedData)) {
            console.warn(
              "Cache size limit would be exceeded, cleaning up old entries",
            );
            this._cleanupOldEntries();

            // Check again after cleanup
            if (this._wouldExceedCacheLimit(serializedData)) {
              console.warn(
                "Cannot cache data - would exceed size limit even after cleanup",
              );
              return false;
            }
          }

          localStorage.setItem(fullKey, serializedData);
          console.log(
            `LocalCache SET: "${key}" with TTL ${ttlMinutes} minutes`,
          );
          return true;
        } catch (error) {
          console.error(`Error setting local cache key "${key}":`, error);
          // Handle quota exceeded error
          if (error.name === "QuotaExceededError") {
            this._handleQuotaExceeded();
          }
          return false;
        }
      }

      /**
       * Retrieve data from localStorage with TTL validation
       * @param {string} key - Cache key
       * @returns {any|null} - Cached data or null if not found/expired
       */
      get(key) {
        try {
          const fullKey = this.CACHE_PREFIX + key;
          const serializedData = localStorage.getItem(fullKey);

          if (!serializedData) {
            console.log(`LocalCache MISS: "${key}" - not found`);
            return null;
          }

          const cacheEntry = JSON.parse(serializedData);

          // Check version compatibility
          if (cacheEntry.version !== this.VERSION) {
            console.log(`LocalCache MISS: "${key}" - version mismatch`);
            this.invalidate(key);
            return null;
          }

          // Check if expired
          if (Date.now() > cacheEntry.expiresAt) {
            console.log(`LocalCache MISS: "${key}" - expired`);
            this.invalidate(key);
            return null;
          }

          console.log(`LocalCache HIT: "${key}"`);
          return cacheEntry.data;
        } catch (error) {
          console.error(`Error getting local cache key "${key}":`, error);
          return null;
        }
      }

      /**
       * Check if cache entry exists and is valid
       * @param {string} key - Cache key
       * @returns {boolean} - True if valid
       */
      isValid(key) {
        try {
          const fullKey = this.CACHE_PREFIX + key;
          const serializedData = localStorage.getItem(fullKey);

          if (!serializedData) return false;

          const cacheEntry = JSON.parse(serializedData);
          return (
            cacheEntry.version === this.VERSION &&
            Date.now() <= cacheEntry.expiresAt
          );
        } catch (error) {
          return false;
        }
      }

      /**
       * Remove specific cache entry
       * @param {string} key - Cache key to remove
       */
      invalidate(key) {
        try {
          const fullKey = this.CACHE_PREFIX + key;
          localStorage.removeItem(fullKey);
          console.log(`LocalCache INVALIDATED: "${key}"`);
        } catch (error) {
          console.error(
            `Error invalidating local cache key "${key}":`,
            error,
          );
        }
      }

      /**
       * Clear all cache entries for this app
       */
      clearAll() {
        try {
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.CACHE_PREFIX)) {
              keysToRemove.push(key);
            }
          }

          keysToRemove.forEach((key) => localStorage.removeItem(key));
          console.log(`LocalCache cleared ${keysToRemove.length} entries`);
        } catch (error) {
          console.error("Error clearing local cache:", error);
        }
      }

      /**
       * Get cache statistics and info
       * @returns {Object} - Cache statistics
       */
      getStats() {
        try {
          let totalSize = 0;
          let entryCount = 0;
          let expiredCount = 0;
          const now = Date.now();

          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.CACHE_PREFIX)) {
              entryCount++;
              const data = localStorage.getItem(key);
              if (data) {
                totalSize += data.length;

                try {
                  const cacheEntry = JSON.parse(data);
                  if (now > cacheEntry.expiresAt) {
                    expiredCount++;
                  }
                } catch (e) {
                  expiredCount++; // Count parse errors as expired
                }
              }
            }
          }

          return {
            entryCount,
            expiredCount,
            totalSizeBytes: totalSize,
            totalSizeKB: Math.round(totalSize / 1024),
            maxSizeKB: Math.round(this.MAX_CACHE_SIZE / 1024),
            usagePercent: Math.round((totalSize / this.MAX_CACHE_SIZE) * 100),
          };
        } catch (error) {
          console.error("Error getting cache stats:", error);
          return { error: error.message };
        }
      }

      /**
       * Clean up expired entries
       */
      cleanupExpired() {
        try {
          const keysToRemove = [];
          const now = Date.now();

          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.CACHE_PREFIX)) {
              const data = localStorage.getItem(key);
              if (data) {
                try {
                  const cacheEntry = JSON.parse(data);
                  if (
                    now > cacheEntry.expiresAt ||
                    cacheEntry.version !== this.VERSION
                  ) {
                    keysToRemove.push(key);
                  }
                } catch (e) {
                  keysToRemove.push(key); // Remove unparseable entries
                }
              }
            }
          }

          keysToRemove.forEach((key) => localStorage.removeItem(key));

          if (keysToRemove.length > 0) {
            console.log(
              `LocalCache cleaned up ${keysToRemove.length} expired entries`,
            );
          }

          return keysToRemove.length;
        } catch (error) {
          console.error("Error cleaning up expired cache entries:", error);
          return 0;
        }
      }

      /**
       * Private method to check if adding data would exceed cache limit
       * @param {string} serializedData - Data to be added
       * @returns {boolean} - True if would exceed limit
       */
      _wouldExceedCacheLimit(serializedData) {
        try {
          const stats = this.getStats();
          const newDataSize = serializedData.length;
          return stats.totalSizeBytes + newDataSize > this.MAX_CACHE_SIZE;
        } catch (error) {
          return false; // Assume it's okay if we can't calculate
        }
      }

      /**
       * Private method to clean up old entries when approaching size limit
       */
      _cleanupOldEntries() {
        try {
          const entries = [];

          // Collect all cache entries with timestamps
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.CACHE_PREFIX)) {
              const data = localStorage.getItem(key);
              if (data) {
                try {
                  const cacheEntry = JSON.parse(data);
                  entries.push({
                    key: key,
                    timestamp: cacheEntry.timestamp,
                    size: data.length,
                  });
                } catch (e) {
                  // Remove unparseable entries immediately
                  localStorage.removeItem(key);
                }
              }
            }
          }

          // Sort by timestamp (oldest first) and remove oldest 25%
          entries.sort((a, b) => a.timestamp - b.timestamp);
          const toRemove = Math.ceil(entries.length * 0.25);

          for (let i = 0; i < toRemove; i++) {
            localStorage.removeItem(entries[i].key);
          }

          console.log(
            `LocalCache removed ${toRemove} old entries to free space`,
          );
        } catch (error) {
          console.error("Error cleaning up old cache entries:", error);
        }
      }

      /**
       * Private method to handle quota exceeded errors
       */
      _handleQuotaExceeded() {
        console.warn("LocalStorage quota exceeded, attempting cleanup");

        // First try cleaning expired entries
        const expiredCleaned = this.cleanupExpired();

        // If that's not enough, clean up old entries
        if (expiredCleaned === 0) {
          this._cleanupOldEntries();
        }
      }
    }

    function appData() {
      return {
        dateString: "",
        periodString: "",
        nextPeriodString: "",
        teachers: [],
        detectedTeacher: "",
        userEmail: "",
        students: [],
        isLoading: false,
        loadingMessage: "",
        lastActionTime: 0,
        lastUpdateTimestamp: 0,
        refreshInterval: null,

        // Search functionality
        searchTerm: "",
        searchResults: [],
        allStudents: [], // Cache of all students for dropdown
        showSearchResults: false,
        isSearching: false,
        searchTimeout: null,
        studentsLoaded: false, // Track if we've loaded all students
        highlightedIndex: -1, // For keyboard navigation

        // Initialize LocalDataCache instance
        localCache: new LocalDataCache(),

        // Initialize OptimisticUI instance (will be set in init())
        optimisticUI: null,

        // Initialize SmartPollingManager instance
        smartPolling: new SmartPollingManager(),

        init() {
          // Initialize OptimisticUI with app context
          this.optimisticUI = new OptimisticUI(this);

          this.loadUserInfo();

          // Ensure active students are loaded after a short delay to allow UI to initialize
          setTimeout(() => {
            if (this.students.length === 0) {
              console.log("No active students found after initialization, forcing reload...");
              this.refreshData();
            }
          }, 2000);

          // Update period every minute
          setInterval(() => {
            const now = new Date();
            this.periodString = this.getCurrentPeriod(now);
            this.nextPeriodString = this.getNextPeriod(now);
          }, 60000);

          // Check for auto-removal only at the specific times: 12:00 PM and 12:00 AM
          setInterval(() => {
            const now = new Date();
            const hour = now.getHours();
            const minute = now.getMinutes();

            // Only run auto-removal at exactly 12:00 PM (noon) and 12:00 AM (midnight)
            if ((hour === 12 && minute === 0) || (hour === 0 && minute === 0)) {
              const removedCount = this.autoRemoveExpiredStudents();
              if (removedCount > 0) {
                const timeLabel = hour === 12 ? "noon" : "midnight";
                console.log(`Auto-removed ${removedCount} students at ${timeLabel} (${now.toLocaleTimeString()})`);
              }
            }
          }, 60000); // Check every minute, but only act at 12:00 PM and 12:00 AM

          // Clean up old optimistic updates every 30 seconds
          setInterval(() => {
            const cleaned = this.optimisticUI.cleanupOldUpdates(30000); // 30 seconds
            if (cleaned > 0) {
              console.log(`Cleaned up ${cleaned} old optimistic updates`);
            }
          }, 30000);

          // Clean up expired cache entries every 5 minutes
          setInterval(() => {
            const cleaned = this.localCache.cleanupExpired();
            if (cleaned > 0) {
              console.log(`Cleaned up ${cleaned} expired cache entries`);
            }
          }, 300000);

          // Log performance stats every 10 minutes for monitoring
          setInterval(() => {
            this._logPerformanceReport();
          }, 600000); // 10 minutes

          // Also log performance stats every 2 minutes during active usage
          setInterval(() => {
            const pollingStats = this.smartPolling.getStats();
            if (pollingStats.activityLevel === "active") {
              this._logPerformanceReport(true);
            }
          }, 120000); // 2 minutes
        },

        // Method to get comprehensive performance stats
        getPerformanceStats() {
          return {
            polling: this.smartPolling.getStats(),
            cache: this.localCache.getStats(),
            optimisticUpdates: this.optimisticUI.getPendingUpdates(),
            lastUpdateTimestamp: this.lastUpdateTimestamp,
            lastActionTime: this.lastActionTime,
          };
        },

        // Bell Schedule Configuration
        // Unified NAMS Bell Schedule 2025-2026 (combining 4th & 5th periods)
        getBellSchedule() {
          return [
            { period: "1st", start: "8:40", end: "9:26" },
            { period: "2nd", start: "9:30", end: "10:16" },
            { period: "3rd", start: "10:20", end: "11:06" },
            { period: "4th & 5th", start: "11:10", end: "1:21" },
            { period: "6th", start: "1:25", end: "2:11" },
            { period: "7th", start: "2:15", end: "3:01" },
            { period: "8th", start: "3:05", end: "3:55" },
          ];
        },

        // Convert time string (e.g., "8:40", "1:21") to minutes since midnight
        // Assumes times after 1:00 and before 8:00 are PM
        timeToMinutes(timeStr) {
          const [hours, minutes] = timeStr.split(":").map(Number);
          let adjustedHours = hours;

          // Convert to 24-hour format
          // Times from 1:00 to 7:59 are assumed to be PM (afternoon/evening)
          if (hours >= 1 && hours <= 7) {
            adjustedHours = hours + 12;
          }

          const result = adjustedHours * 60 + minutes;
          console.log(
            `timeToMinutes("${timeStr}") = ${adjustedHours}*60 + ${minutes} = ${result} (original hours: ${hours})`,
          );
          return result;
        },

        // Get the current period based on time
        getCurrentPeriod(now = new Date()) {
          const currentTime = now.getHours() * 60 + now.getMinutes();
          const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.

          // Debug logging
          console.log("Current time debug:", {
            fullDate: now.toString(),
            hours: now.getHours(),
            minutes: now.getMinutes(),
            currentTimeInMinutes: currentTime,
            dayOfWeek: dayOfWeek,
            timeString: now.toLocaleTimeString(),
          });

          // School only operates Monday-Friday
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            return "Weekend - No School";
          }

          // Before school starts (8:40 = 520 minutes)
          const schoolStartMinutes = this.timeToMinutes("8:40");
          console.log(
            "School start check:",
            currentTime,
            "<",
            schoolStartMinutes,
            "=",
            currentTime < schoolStartMinutes,
          );
          if (currentTime < schoolStartMinutes) {
            return "Before School";
          }

          // After school ends (3:55 = 955 minutes)
          const schoolEndMinutes = this.timeToMinutes("3:55");
          console.log(
            "School end check:",
            currentTime,
            ">",
            schoolEndMinutes,
            "=",
            currentTime > schoolEndMinutes,
          );
          if (currentTime > schoolEndMinutes) {
            return "After School";
          }

          // Get the unified schedule
          const periods = this.getBellSchedule();

          // Check each period
          for (const period of periods) {
            const startTime = this.timeToMinutes(period.start);
            const endTime = this.timeToMinutes(period.end);

            console.log(
              `Checking ${period.period}:`,
              currentTime,
              "between",
              startTime,
              "and",
              endTime,
            );

            if (currentTime >= startTime && currentTime <= endTime) {
              return `${period.period} (${period.start} - ${period.end})`;
            }
          }

          // Check for passing periods (between classes)
          for (let i = 0; i < periods.length - 1; i++) {
            const currentPeriodEnd = this.timeToMinutes(periods[i].end);
            const nextPeriodStart = this.timeToMinutes(periods[i + 1].start);

            if (
              currentTime > currentPeriodEnd &&
              currentTime < nextPeriodStart
            ) {
              return `Passing Period (${periods[i].period}  ${periods[i + 1].period})`;
            }
          }

          return `Current Time: ${now.toLocaleTimeString()} (${currentTime} minutes)`;
        },

        // Get information about the next period
        getNextPeriod(now = new Date()) {
          const currentTime = now.getHours() * 60 + now.getMinutes();
          const dayOfWeek = now.getDay();

          // School only operates Monday-Friday
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            return "No upcoming periods - Weekend";
          }

          // After school ends
          if (currentTime > this.timeToMinutes("3:55")) {
            return "No more periods today";
          }

          const periods = this.getBellSchedule();

          // Find the next period that hasn't started yet
          for (const period of periods) {
            const startTime = this.timeToMinutes(period.start);

            if (currentTime < startTime) {
              const minutesUntil = startTime - currentTime;
              const hours = Math.floor(minutesUntil / 60);
              const mins = minutesUntil % 60;

              let timeUntil = "";
              if (hours > 0) {
                timeUntil = `${hours}h ${mins}m`;
              } else {
                timeUntil = `${mins}m`;
              }

              return `Next: ${period.period} in ${timeUntil} (${period.start} - ${period.end})`;
            }
          }

          return "No more periods today";
        },

        loadUserInfo() {
          console.log("Loading user information...");

          // Try to get cached user info first
          const cachedUserInfo = this.localCache.get("userInfo");
          const cachedTeachers = this.localCache.get("teacherList");

          if (cachedUserInfo && cachedTeachers) {
            console.log("Using cached user info and teacher list");
            this.userEmail = cachedUserInfo.userEmail;
            this.detectedTeacher = cachedUserInfo.detectedTeacher;
            this.teachers = cachedTeachers;

            this._initializeDateAndPeriod();
            this.refreshData();
            this.startSmartRefresh();

            // Still fetch fresh data in background to update cache
            this._fetchUserInfoInBackground();
            return;
          }

          // No cache available, fetch from server
          this._fetchUserInfoFromServer();
        },

        _fetchUserInfoFromServer() {
          google.script.run
            .withSuccessHandler((userInfo) => {
              console.log("User info received:", userInfo);
              this.userEmail = userInfo.userEmail;
              this.detectedTeacher = userInfo.detectedTeacher;
              this.teachers = userInfo.teacherList;

              // Cache the user info and teacher list
              this.localCache.set(
                "userInfo",
                {
                  userEmail: userInfo.userEmail,
                  detectedTeacher: userInfo.detectedTeacher,
                },
                1440,
              ); // Cache for 24 hours

              this.localCache.set("teacherList", userInfo.teacherList, 1440); // Cache for 24 hours

              this._initializeDateAndPeriod();
              this.refreshData();
              this.startSmartRefresh();
            })
            .withFailureHandler((error) => {
              console.error("Error loading user info:", error);
              this._useFallbackUserInfo();
            })
            .api_getCurrentUserInfo();
        },

        _fetchUserInfoInBackground() {
          // Silently fetch fresh user info to update cache
          google.script.run
            .withSuccessHandler((userInfo) => {
              console.log("Background user info update received");
              // Update cache with fresh data
              this.localCache.set(
                "userInfo",
                {
                  userEmail: userInfo.userEmail,
                  detectedTeacher: userInfo.detectedTeacher,
                },
                1440,
              );

              this.localCache.set("teacherList", userInfo.teacherList, 1440);

              // Update current data if significantly different
              if (userInfo.detectedTeacher !== this.detectedTeacher) {
                this.detectedTeacher = userInfo.detectedTeacher;
                console.log("Updated detected teacher from background fetch");
              }
            })
            .withFailureHandler((error) => {
              console.log(
                "Background user info fetch failed (not critical):",
                error,
              );
            })
            .api_getCurrentUserInfo();
        },

        _useFallbackUserInfo() {
          // Use fallback teacher list
          const fallbackTeachers = [
            "Mr. Aguilar",
            "Mrs. Atoui",
            "Mrs. Bowery",
            "Mrs. Cantu",
            "Mr. Casanova",
            "Mrs. Coyle",
            "Mr. De Leon",
            "Mrs. Farias",
            "Mr. Franco",
            "Mr. Garcia",
            "Mr. Goff",
            "Mr. Gomez",
            "Dr. Gonzales",
            "Mr. Hernandez",
            "Mrs. Hutton",
            "Mrs. Idrogo",
            "Mrs. Jasso",
            "Mrs. Marquez",
            "Mr. Ollendieck",
            "Mr. Paez",
            "Mr. Ramon",
            "Mrs. Tellez",
            "Mr. Trevino",
            "Mrs. Wine",
            "Mrs. Yeager",
            "Other Teacher",
          ];

          this.teachers = fallbackTeachers;
          this.detectedTeacher = "Other Teacher";

          // Cache fallback data
          this.localCache.set("teacherList", fallbackTeachers, 60); // Cache for 1 hour only
          this.localCache.set(
            "userInfo",
            {
              userEmail: "",
              detectedTeacher: "Other Teacher",
            },
            60,
          );

          this._initializeDateAndPeriod();
          this.refreshData();
          this.startSmartRefresh();
        },

        _initializeDateAndPeriod() {
          const now = new Date();
          this.dateString = now.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });
          this.periodString = this.getCurrentPeriod(now);
          this.nextPeriodString = this.getNextPeriod(now);
        },

        refreshData() {
          console.log(
            "refreshData() called - loading active students from Log sheet",
          );

          // Load only active students (those currently being managed)
          this.isLoading = true;
          this.loadingMessage = "Loading active students from Log sheet...";
          this.loadStartTime = Date.now();

          google.script.run
            .withSuccessHandler((response) => {
              const responseTime = Date.now() - this.loadStartTime;
              console.log(
                " Active students loaded successfully from Log sheet:",
                response,
              );
              console.log(` Load response time: ${responseTime}ms`);

              if (
                response &&
                response.success &&
                response.data
              ) {
                console.log(
                  `Active students from Log: ${response.metadata.activeStudentCount}`,
                );
                this._handleStudentDataSuccess(response.data);

                // Start smart polling after successful initial load
                this.startSmartRefresh();

                // Log what we found
                if (response.metadata.activeStudentCount === 0) {
                  console.log(" No active students found in Log sheet - this is normal if all students have returned or none are currently using the restroom");
                }
              } else {
                console.warn("Active students endpoint failed:", response?.error);
                this.isLoading = false;
                this.loadingMessage = "";
              }
            })
            .withFailureHandler((error) => {
              const responseTime = Date.now() - this.loadStartTime;
              console.error("Active students endpoint failed:", error);
              console.log(` Failed load response time: ${responseTime}ms`);
              this.isLoading = false;
              this.loadingMessage = "";
            })
            .api_getActiveStudentsFinal();
        },

        _fetchStudentDataFromServer() {
          console.log(
            "Fetching student data from server with optimized cached loading",
          );
          this.isLoading = true;
          this.loadingMessage = "Loading student data...";
          this.loadStartTime = Date.now(); // Track load start time

          // Use the optimized cached data endpoint first
          google.script.run
            .withSuccessHandler((response) => {
              const responseTime = Date.now() - this.loadStartTime;
              console.log(
                " Cached student data loaded successfully:",
                response,
              );
              console.log(` Server response time: ${responseTime}ms`);

              if (
                response &&
                response.success &&
                response.data &&
                response.data.students
              ) {
                console.log(
                  `Cache used: ${response.metadata.cacheUsed}, Students: ${response.metadata.studentCount}`,
                );

                // Log cache hit/miss
                if (response.metadata.cacheUsed) {
                  console.log(" Cache HIT - Data served from server cache");
                } else {
                  console.log(
                    " Cache MISS - Data loaded fresh from sheets",
                  );
                }

                this._handleStudentDataSuccess(response.data);
              } else if (response && !response.success) {
                console.warn(
                  "Cached endpoint failed, falling back...",
                  response.error,
                );
                this.loadingMessage = "Trying fallback method...";
                this.fallbackToMinimalBypass();
              } else {
                console.warn(
                  "Cached endpoint returned invalid data, falling back...",
                );
                this.loadingMessage = "Trying fallback method...";
                this.fallbackToMinimalBypass();
              }
            })
            .withFailureHandler((error) => {
              const responseTime = Date.now() - this.loadStartTime;
              console.error("Cached endpoint failed:", error);
              console.log(` Failed response time: ${responseTime}ms`);
              this.loadingMessage = "Trying fallback method...";
              this.fallbackToMinimalBypass();
            })
            .api_getActiveStudents();
        },

        _fetchStudentDataInBackground() {
          console.log(
            "Fetching fresh student data in background using optimized endpoint",
          );

          // Fetch fresh data without loading indicator using optimized cached endpoint
          google.script.run
            .withSuccessHandler((response) => {
              console.log("Background student data update received");

              if (
                response &&
                response.success &&
                response.data &&
                response.data.students
              ) {
                const data = response.data;

                // Check if data has actually changed before updating UI
                const hasChanges = this._hasStudentDataChanged(data);

                if (hasChanges) {
                  console.log("Student data changes detected, updating UI");
                  this._handleStudentDataSuccess(data, false); // false = no loading indicator
                } else {
                  console.log("No student data changes detected");
                  // Still update cache with fresh timestamp
                  this.localCache.set("studentData", data, 30); // 30 minutes cache


                }
              } else {
                console.log(
                  "Background fetch returned invalid data (not critical):",
                  response,
                );


              }
            })
            .withFailureHandler((error) => {
              console.log(
                "Background student data fetch failed (not critical):",
                error,
              );


            })
            .api_getActiveStudents();
        },

        _handleStudentDataSuccess(data, showLoading = true) {
          const startTime = this.loadStartTime || Date.now();
          const loadTime = Date.now() - startTime;

          // Preserve completed students who shouldn't be auto-removed yet
          const completedStudentsToKeep = [];
          if (this.students && this.students.length > 0) {
            this.students.forEach(student => {
              // Keep students who have completed their trip but shouldn't be auto-removed yet
              if (student.outTime && student.backTime && !this.shouldAutoRemoveStudent(student)) {
                completedStudentsToKeep.push(student);
                console.log(`Preserving completed student: ${student.name} (used restroom at ${student.outTime})`);
              }
            });
          }

          // Set new active students from server
          this.students = data.students || [];

          // Add back the completed students that should be preserved
          completedStudentsToKeep.forEach(student => {
            // Only add if not already in the new data
            const existingStudent = this.students.find(s => s.name === student.name);
            if (!existingStudent) {
              this.students.push(student);
              console.log(`Re-added completed student: ${student.name}`);
            }
          });

          // Sort students: active students first, completed students last
          this.sortStudentsByStatus();

          // Cache the student data
          this.localCache.set("studentData", data, 30); // Cache for 30 minutes

          if (showLoading) {
            this.isLoading = false;
            this.loadingMessage = "";
          }

          this.lastUpdateTimestamp = Date.now();

          // Performance monitoring and validation
          console.log(" Student data applied successfully");
          console.log(` Load time: ${loadTime}ms`);

          // Validate performance targets
          this._validatePerformanceTargets(loadTime, showLoading);

          // Log cache statistics
          this._logCacheStatistics();
        },

        // Validate that performance targets are met
        _validatePerformanceTargets(loadTime, isInitialLoad) {
          const targetInitialLoad = 3000; // 3 seconds for initial load
          const targetUpdate = 1000; // 1 second for updates

          const target = isInitialLoad ? targetInitialLoad : targetUpdate;
          const targetType = isInitialLoad ? "initial load" : "update";

          if (loadTime <= target) {
            console.log(
              ` Performance target met: ${targetType} completed in ${loadTime}ms (target: ${target}ms)`,
            );
          } else {
            console.warn(
              ` Performance target missed: ${targetType} took ${loadTime}ms (target: ${target}ms)`,
            );
          }

          // Store performance metrics for monitoring
          if (!this.performanceMetrics) {
            this.performanceMetrics = {
              loadTimes: [],
              updateTimes: [],
              targetsMet: 0,
              targetsMissed: 0,
            };
          }

          if (isInitialLoad) {
            this.performanceMetrics.loadTimes.push(loadTime);
          } else {
            this.performanceMetrics.updateTimes.push(loadTime);
          }

          if (loadTime <= target) {
            this.performanceMetrics.targetsMet++;
          } else {
            this.performanceMetrics.targetsMissed++;
          }
        },

        // Log cache statistics for monitoring
        _logCacheStatistics() {
          const cacheStats = this.localCache.getStats();
          const pollingStats = this.smartPolling.getStats();

          console.log(" Cache Statistics:", {
            hitRate:
              cacheStats.entryCount > 0
                ? `${Math.round(((cacheStats.entryCount - cacheStats.expiredCount) / cacheStats.entryCount) * 100)}%`
                : "0%",
            size: `${cacheStats.totalSizeKB}KB`,
            usage: `${cacheStats.usagePercent}%`,
            entries: cacheStats.entryCount,
            expired: cacheStats.expiredCount,
          });

          console.log(" Polling Statistics:", {
            activityLevel: pollingStats.activityLevel,
            updateRate: pollingStats.updateRate,
            totalChecks: pollingStats.totalChecks,
            updatesFound: pollingStats.updatesFound,
            averageInterval: `${Math.round(pollingStats.averageInterval / 1000)}s`,
          });
        },

        _hasStudentDataChanged(newData) {
          // Simple comparison - check if student count or queue lengths changed
          if (
            !this.students ||
            this.students.length !== newData.students.length
          ) {
            return true;
          }



          // Check for status changes in first few students (most likely to change)
          for (let i = 0; i < Math.min(5, this.students.length); i++) {
            const current = this.students[i];
            const updated = newData.students[i];

            if (
              current &&
              updated &&
              (current.outTime !== updated.outTime ||
                current.backTime !== updated.backTime ||
                current.holdNotice !== updated.holdNotice)
            ) {
              return true;
            }
          }

          return false;
        },

        // Start smart refresh system using SmartPollingManager
        startSmartRefresh() {
          console.log(
            "Starting smart refresh system with SmartPollingManager...",
          );

          // Initialize last update timestamp
          this.lastUpdateTimestamp = Date.now();

          // Start adaptive polling with update callback
          this.smartPolling.startAdaptivePolling(
            (updateInfo) => {
              // Update callback - called when updates are detected
              console.log("SmartPolling detected updates:", updateInfo);

              if (updateInfo.fallback) {
                // Fallback mode - do full refresh
                console.log(
                  "Using fallback mode - performing full refresh...",
                );
                this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
                this._fetchStudentDataInBackground();
              } else if (
                updateInfo &&
                updateInfo.success &&
                updateInfo.hasUpdates
              ) {
                // Incremental updates available
                console.log("Processing incremental updates...");
                this._handleIncrementalUpdates(updateInfo);
                this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
              } else if (
                updateInfo &&
                updateInfo.success &&
                !updateInfo.hasUpdates
              ) {
                // No updates, just update timestamp
                console.log("No updates detected, keeping current data");
                this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
              } else {
                // Unknown response, do full refresh to be safe
                console.log(
                  "Unknown update response, performing full refresh...",
                );
                this.lastUpdateTimestamp = Date.now();
                this._fetchStudentDataInBackground();
              }
            },
            (activityLevel) => {
              // Activity level change callback
              console.log(`User activity level changed to: ${activityLevel}`);
            },
          );
        },

        // Handle incremental updates from the optimized endpoint
        _handleIncrementalUpdates(updateInfo) {
          console.log("Handling incremental updates:", updateInfo);

          if (!updateInfo.updates || !updateInfo.changedStudents) {
            console.log(
              "No specific update data, falling back to full refresh",
            );
            this._fetchStudentDataInBackground();
            return;
          }

          let hasChanges = false;

          // Update specific students that have changed
          updateInfo.changedStudents.forEach((studentName) => {
            const studentUpdate = updateInfo.updates[studentName];
            if (!studentUpdate) return;

            const studentIndex = this.students.findIndex(
              (s) => s.name === studentName,
            );
            if (studentIndex !== -1) {
              const currentStudent = this.students[studentIndex];

              // Check if there are actual changes
              if (
                currentStudent.outTime !== studentUpdate.outTime ||
                currentStudent.backTime !== studentUpdate.backTime ||
                currentStudent.holdNotice !== studentUpdate.holdNotice ||
                currentStudent.gender !== studentUpdate.gender ||
                currentStudent.teacher !== studentUpdate.teacher
              ) {
                // Apply the update
                this.students[studentIndex] = {
                  ...currentStudent,
                  gender: studentUpdate.gender || currentStudent.gender,
                  teacher: studentUpdate.teacher || currentStudent.teacher,
                  outTime: studentUpdate.outTime || "",
                  backTime: studentUpdate.backTime || "",
                  holdNotice: studentUpdate.holdNotice || "",
                };

                hasChanges = true;
                console.log(`Updated student ${studentName} incrementally`);
              }
            }
          });

          if (hasChanges) {
            // Update local cache with new data
            this.localCache.set(
              "studentData",
              {
                students: this.students,
              },
              30,
            );

            console.log("Incremental updates applied successfully");
          } else {
            console.log("No actual changes detected in incremental update");
          }
        },

        // Stop smart refresh system
        stopSmartRefresh() {
          console.log("Stopping smart refresh system...");
          if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
          }
          this.smartPolling.stopPolling();
        },

        // Track user actions and notify SmartPollingManager
        recordUserAction() {
          this.lastActionTime = Date.now();
          this.smartPolling.recordUserActivity();
          console.log(
            "User action recorded and reported to SmartPollingManager",
          );
        },

        // Manual refresh triggered by user
        manualRefresh() {
          console.log("Manual refresh triggered by user");
          this.recordUserAction();

          // Clear local cache to force fresh data
          this.localCache.clearAll();

          // Refresh only active students (not all students from roster)
          this.refreshData();
        },



        // Test server connection with a simple function
        testServerConnection() {
          console.log("Testing server connection...");

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Server test response:", response);
              alert(`Server connection test successful!\nResponse: ${JSON.stringify(response, null, 2)}`);
            })
            .withFailureHandler((error) => {
              console.error("Server test failed:", error);
              alert(`Server connection test failed: ${error.message || error}`);
            })
            .api_debugLogSheet();
        },

        // Test the simple version of getActiveStudents
        testSimpleReload() {
          console.log("Testing simple active students reload...");
          this.isLoading = true;
          this.loadingMessage = "Testing simple reload...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Simple reload response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Simple version also returned null - there's a deeper server issue");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Simple version SUCCESS! Loaded ${this.students.length} students.\nThis means the usage limit check was causing the issue.`);
              } else {
                alert(`Simple version failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Simple reload failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Simple reload failed: ${error.message || error}`);
            })
            .api_getActiveStudentsSimple();
        },

        // Test the direct version that reads Log sheet directly
        testDirectReload() {
          console.log("Testing direct active students reload...");
          this.isLoading = true;
          this.loadingMessage = "Testing direct reload...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Direct reload response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Direct version also returned null - this is very strange!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Direct version SUCCESS! Loaded ${this.students.length} students.\nThis bypasses the _getCurrentRestroomStatusFallback function entirely.`);
              } else {
                alert(`Direct version failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Direct reload failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Direct reload failed: ${error.message || error}`);
            })
            .api_getActiveStudentsDirect();
        },

        // Test deployment with a simple hardcoded response
        testDeployment() {
          console.log("Testing deployment with simple function...");
          this.isLoading = true;
          this.loadingMessage = "Testing deployment...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Deployment test response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Deployment test returned null - there's a serious deployment issue!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Deployment test SUCCESS! Loaded ${this.students.length} test students.\nThis proves the deployment is working and the issue is with the Log sheet reading functions.`);
              } else {
                alert(`Deployment test failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Deployment test failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Deployment test failed: ${error.message || error}`);
            })
            .api_testDeployment();
        },

        // Test the hybrid version that uses debug logic but returns student format
        testHybridReload() {
          console.log("Testing hybrid active students reload...");
          this.isLoading = true;
          this.loadingMessage = "Testing hybrid reload...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Hybrid reload response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Hybrid version also returned null - something is very wrong!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Hybrid version SUCCESS! Loaded ${this.students.length} students.\nThis uses the working debug logic but returns the correct format!`);
              } else {
                alert(`Hybrid version failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Hybrid reload failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Hybrid reload failed: ${error.message || error}`);
            })
            .api_getActiveStudentsHybrid();
        },

        // Test spreadsheet access
        testSpreadsheetAccess() {
          console.log("Testing spreadsheet access...");
          this.isLoading = true;
          this.loadingMessage = "Testing spreadsheet access...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Spreadsheet access response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Spreadsheet access test returned null - there's a serious issue!");
                return;
              }

              if (response && response.success) {
                alert(`Spreadsheet access SUCCESS!\nTotal rows: ${response.data.totalRows}\nThis means the issue is not with spreadsheet access.`);
              } else {
                alert(`Spreadsheet access failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Spreadsheet access test failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Spreadsheet access test failed: ${error.message || error}`);
            })
            .api_testSpreadsheetAccess();
        },

        // Test minimal function
        testMinimal() {
          console.log("Testing minimal function...");
          this.isLoading = true;
          this.loadingMessage = "Testing minimal function...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Minimal test response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Minimal test returned null - the issue is with the return format!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Minimal test SUCCESS! Loaded ${this.students.length} students.\nThis proves the return format works.`);
              } else {
                alert(`Minimal test failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Minimal test failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Minimal test failed: ${error.message || error}`);
            })
            .api_testMinimal();
        },

        // Test getting one active student using debug logic
        testOneStudent() {
          console.log("Testing one active student...");
          this.isLoading = true;
          this.loadingMessage = "Testing one active student...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("One student test response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("One student test returned null - the issue is with Log sheet processing!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`One student test SUCCESS! Found ${this.students.length} active students.\nThis uses the exact debug logic but returns student format!`);
              } else {
                alert(`One student test failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("One student test failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`One student test failed: ${error.message || error}`);
            })
            .api_getOneActiveStudent();
        },

        // Test debug function converted to student format
        testDebugAsStudents() {
          console.log("Testing debug function as students...");
          this.isLoading = true;
          this.loadingMessage = "Testing debug as students...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Debug as students response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Debug as students returned null - this is the smoking gun!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Debug as students SUCCESS! Found ${this.students.length} active students.\nThis is the exact debug logic converted to student format!`);
              } else {
                alert(`Debug as students failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Debug as students failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Debug as students failed: ${error.message || error}`);
            })
            .api_debugAsStudents();
        },

        // Test the simplest possible student object
        testSimplestStudent() {
          console.log("Testing simplest student object...");
          this.isLoading = true;
          this.loadingMessage = "Testing simplest student...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Simplest student response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Even the simplest student object returns null - there's a fundamental issue!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Simplest student SUCCESS! This proves the basic structure works.`);
              } else {
                alert(`Simplest student failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Simplest student failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Simplest student failed: ${error.message || error}`);
            })
            .api_testSimplestStudent();
        },



        // Test reading real Log data with minimal processing
        testRealLogMinimal() {
          console.log("Testing real Log data with minimal processing...");
          this.isLoading = true;
          this.loadingMessage = "Testing real Log minimal...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Real Log minimal response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Real Log minimal returned null - the issue is with Log data processing!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Real Log minimal SUCCESS! Found ${this.students.length} students.\nThis proves we can read real Log data.`);
              } else {
                alert(`Real Log minimal failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Real Log minimal failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Real Log minimal failed: ${error.message || error}`);
            })
            .api_testRealLogMinimal();
        },

        // Test reading real Log data with complete student object
        testRealLogComplete() {
          console.log("Testing real Log data with complete student object...");
          this.isLoading = true;
          this.loadingMessage = "Testing real Log complete...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Real Log complete response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Real Log complete returned null - the issue is with the complete student object!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Real Log complete SUCCESS! Found ${this.students.length} active students.\nThis should be your actual active student!`);
              } else {
                alert(`Real Log complete failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Real Log complete failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Real Log complete failed: ${error.message || error}`);
            })
            .api_testRealLogComplete();
        },

        // Test adding fields one by one to find the problematic field
        testFieldByField() {
          console.log("Testing fields one by one...");
          this.isLoading = true;
          this.loadingMessage = "Testing field by field...";

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Field by field response:", response);
              this.isLoading = false;
              this.loadingMessage = "";

              if (response === null || response === undefined) {
                alert("Field by field returned null - even name + id fails!");
                return;
              }

              if (response && response.success && response.data) {
                this.students = response.data.students || [];
                alert(`Field by field SUCCESS! Found ${this.students.length} students with name + id fields.\nNow we can add more fields to find the problem.`);
              } else {
                alert(`Field by field failed: ${response?.error || "Unknown error"}`);
              }
            })
            .withFailureHandler((error) => {
              console.error("Field by field failed:", error);
              this.isLoading = false;
              this.loadingMessage = "";
              alert(`Field by field failed: ${error.message || error}`);
            })
            .api_testFieldByField();
        },

        // Debug method to show current state and Log sheet contents
        debugCurrentState() {
          console.log("=== DEBUG: Current Application State ===");
          console.log("Current students array:", this.students);
          console.log("Students count:", this.students.length);
          console.log("Is loading:", this.isLoading);
          console.log("Loading message:", this.loadingMessage);

          // Also call server-side debug to check Log sheet
          google.script.run
            .withSuccessHandler((debugInfo) => {
              console.log("=== DEBUG: Server-side Log Sheet Analysis ===");
              console.log("Debug info from server:", debugInfo);

              // Show user-friendly alert
              const message = `
DEBUG INFORMATION:
 Current students in UI: ${this.students.length}
 Today's Log entries: ${debugInfo.todayEntries || 'N/A'}
 Active students in Log: ${debugInfo.activeStudents || 'N/A'}
 Students currently out: ${debugInfo.studentsOut || 'N/A'}
 Students waiting: ${debugInfo.studentsWaiting || 'N/A'}

Check browser console for detailed logs.
              `.trim();

              alert(message);
            })
            .withFailureHandler((error) => {
              console.error("Debug call failed:", error);
              alert(`Debug failed: ${error.message || error}`);
            })
            .api_debugLogSheet();
        },

        // Format timestamp for display
        formatTimestamp(timestamp) {
          if (!timestamp) return "Never";

          const now = Date.now();
          const diff = now - timestamp;

          if (diff < 60000) {
            // Less than 1 minute
            return `${Math.round(diff / 1000)}s ago`;
          } else if (diff < 3600000) {
            // Less than 1 hour
            return `${Math.round(diff / 60000)}m ago`;
          } else {
            return new Date(timestamp).toLocaleTimeString();
          }
        },

        // Format last update time for display
        formatLastUpdate() {
          return this.formatTimestamp(this.lastUpdateTimestamp);
        },

        // Log comprehensive performance report
        _logPerformanceReport(isActiveReport = false) {
          const pollingStats = this.smartPolling.getStats();
          const cacheStats = this.localCache.getStats();
          const perfMetrics = this.performanceMetrics || {
            loadTimes: [],
            updateTimes: [],
            targetsMet: 0,
            targetsMissed: 0,
          };

          const avgLoadTime =
            perfMetrics.loadTimes.length > 0
              ? Math.round(
                perfMetrics.loadTimes.reduce((a, b) => a + b, 0) /
                perfMetrics.loadTimes.length,
              )
              : 0;

          const avgUpdateTime =
            perfMetrics.updateTimes.length > 0
              ? Math.round(
                perfMetrics.updateTimes.reduce((a, b) => a + b, 0) /
                perfMetrics.updateTimes.length,
              )
              : 0;

          const totalTargets =
            perfMetrics.targetsMet + perfMetrics.targetsMissed;
          const targetSuccessRate =
            totalTargets > 0
              ? Math.round((perfMetrics.targetsMet / totalTargets) * 100)
              : 100; // 100% if no targets measured yet

          const reportType = isActiveReport ? "ACTIVE USER" : "PERIODIC";

          console.log(` ${reportType} PERFORMANCE REPORT:`);
          console.log("Performance Targets:", {
            successRate: `${targetSuccessRate}%`,
            avgLoadTime: `${avgLoadTime}ms`,
            avgUpdateTime: `${avgUpdateTime}ms`,
            loadOps: perfMetrics.loadTimes.length,
            updateOps: perfMetrics.updateTimes.length,
            targetsMet: perfMetrics.targetsMet,
            targetsMissed: perfMetrics.targetsMissed,
          });

          console.log("Smart Polling:", {
            activityLevel: pollingStats.activityLevel,
            updateRate: pollingStats.updateRate,
            totalChecks: pollingStats.totalChecks,
            updatesFound: pollingStats.updatesFound,
            avgInterval: `${Math.round(pollingStats.averageInterval / 1000)}s`,
            timeSinceActivity: `${Math.round(pollingStats.timeSinceLastActivity / 1000)}s`,
          });

          console.log("Cache Performance:", {
            hitRate: `${cacheStats.entryCount > 0 ? Math.round(((cacheStats.entryCount - cacheStats.expiredCount) / cacheStats.entryCount) * 100) : 0}%`,
            usage: `${cacheStats.usagePercent}%`,
            size: `${cacheStats.totalSizeKB}KB`,
            entries: cacheStats.entryCount,
            expired: cacheStats.expiredCount,
          });

          const pendingUpdates = this.optimisticUI.getPendingUpdates();
          if (pendingUpdates.length > 0) {
            console.log("Optimistic Updates:", {
              pending: pendingUpdates.length,
              oldestAge: `${Math.round(Math.max(...pendingUpdates.map((u) => u.age)) / 1000)}s`,
            });
          }

          // Alert if performance is degraded
          if (targetSuccessRate < 80 && totalTargets >= 5) {
            console.warn(
              ` Performance Alert: Target success rate is ${targetSuccessRate}% (below 80%)`,
            );
          }

          if (avgLoadTime > 5000 && perfMetrics.loadTimes.length >= 3) {
            console.warn(
              ` Performance Alert: Average load time is ${avgLoadTime}ms (above 5000ms)`,
            );
          }

          if (avgUpdateTime > 2000 && perfMetrics.updateTimes.length >= 5) {
            console.warn(
              ` Performance Alert: Average update time is ${avgUpdateTime}ms (above 2000ms)`,
            );
          }
        },

        fallbackToMinimalBypass() {
          console.log("Using fallback: loading active students only");

          google.script.run
            .withSuccessHandler((response) => {
              console.log("Fallback active students received:", response);

              if (response && response.success && response.data) {
                this._handleStudentDataSuccess(response.data);
              } else {
                console.error("Even fallback failed:", response);
                // Initialize with empty data instead of failing
                this.students = [];
                this.isLoading = false;
                this.loadingMessage = "";
              }
            })
            .withFailureHandler((error) => {
              console.error("Fallback also failed:", error);
              // Initialize with empty data instead of showing alert
              this.students = [];
              this.isLoading = false;
              this.loadingMessage = "";
            })
            .api_getActiveStudents();
        },

        // Fallback method for update operations when optimized endpoints fail
        _fallbackUpdateStatus(
          studentName,
          action,
          teacherName,
          gender,
          updateId,
        ) {
          console.log(
            "Using fallback update method for:",
            studentName,
            action,
          );

          google.script.run
            .withSuccessHandler((resp) => {
              console.log("Fallback update successful:", resp);

              // Confirm optimistic update with server response
              this.optimisticUI.confirmServerUpdate(
                updateId,
                resp,
                (serverState) => {
                  console.log(
                    "Fallback update confirmed, triggering immediate data sync",
                  );
                  // Trigger immediate background refresh and smart polling check
                  setTimeout(() => {
                    this._fetchStudentDataInBackground();
                    // Also trigger immediate smart polling check for other potential updates
                    if (this.smartPolling && this.smartPolling.isActive) {
                      this.smartPolling.checkForUpdates();
                    }
                  }, 100); // Small delay to ensure server-side processing is complete
                },
              );
            })
            .withFailureHandler((error) => {
              console.error("Fallback update also failed:", error);

              // Revert optimistic update on error
              this.optimisticUI.revertOnError(
                updateId,
                (originalState) => {
                  // Revert the student object
                  const studentIndex = this.students.findIndex(
                    (s) => s.name === studentName,
                  );
                  if (studentIndex !== -1) {
                    this.students[studentIndex] = {
                      ...this.students[studentIndex],
                      ...originalState,
                    };

                    // Restore to queue if they were originally waiting (for 'out' action)
                    if (
                      action === "out" &&
                      originalState.holdNotice &&
                      !originalState.outTime
                    ) {

                    }
                  }
                },
                error.message || error,
              );

              const errorMessage = error.message || error.toString() || "Unknown error occurred";
              alert(
                `Error updating student status: ${errorMessage}\n\nThe change has been reverted.`,
              );
            })
            .api_updateStatus(studentName, action, teacherName, gender);
        },

        mergeLogDataFallback() {
          console.log("Attempting to merge log data in fallback mode");

          google.script.run
            .withSuccessHandler((logData) => {
              console.log("Fallback log data received:", logData);

              if (
                logData &&
                logData.todaysEntries &&
                Array.isArray(logData.todaysEntries)
              ) {
                const logEntries = logData.todaysEntries;
                console.log(
                  `Merging ${logEntries.length} log entries in fallback mode`,
                );

                // Merge log data into existing students
                this.students = this.students.map((student) => {
                  const studentLogs = logEntries.filter(
                    (log) => log.studentName === student.name,
                  );

                  if (studentLogs.length > 0) {
                    const latestLog = studentLogs[studentLogs.length - 1];
                    console.log(
                      `Fallback merge for ${student.name}:`,
                      latestLog,
                    );

                    return {
                      ...student,
                      gender: latestLog.gender || student.gender,
                      teacher: latestLog.teacher || student.teacher,
                      outTime: latestLog.outTime
                        ? this.formatDate(latestLog.outTime)
                        : student.outTime,
                      backTime: latestLog.backTime
                        ? this.formatDate(latestLog.backTime)
                        : student.backTime,
                      holdNotice: latestLog.holdNotice || student.holdNotice,
                    };
                  }

                  return student;
                });

                console.log("Fallback log merge completed successfully");
              } else {
                console.log("No log entries to merge in fallback mode");
              }

              // Clear loading state after merge completes
              this.isLoading = false;
              this.loadingMessage = "";
            })
            .withFailureHandler((error) => {
              console.warn("Fallback log merge failed:", error);
              // Continue without log data - don't show error to user since we have basic roster
              this.isLoading = false;
              this.loadingMessage = "";
            })
            .api_debugLogSheet();
        },

        handleFetch(resp) {
          // Check if response is valid
          if (!resp) {
            console.error("Received null response from fetchData");
            alert(
              "Error: No data received from server. Please refresh the page.",
            );
            return;
          }

          if (!resp.students || !Array.isArray(resp.students)) {
            console.error("Invalid response structure:", resp);
            alert(
              "Error: Invalid data structure received from server. Please refresh the page.",
            );
            return;
          }

          // resp has { students, queue }
          console.log("Processing students:", resp.students);
          console.log(
            "Detected teacher for assignment:",
            this.detectedTeacher,
          );

          this.students = resp.students.map((s) => {
            // Since student data from daily sheet doesn't include teacher,
            // assign all students to the currently logged-in teacher
            const assignedTeacher =
              this.detectedTeacher || this.teachers[0] || "Other Teacher";

            const processedStudent = {
              name: s.name,
              gender: s.gender || "",
              teacher: s.teacher || assignedTeacher,
              outTime: s.outTime ? this.formatDate(s.outTime) : "",
              backTime: s.backTime ? this.formatDate(s.backTime) : "",
              holdNotice: s.holdNotice || "",
            };

            // Ensure teacher is always set to detected teacher if not already assigned
            if (
              !processedStudent.teacher ||
              processedStudent.teacher.trim() === "" ||
              processedStudent.teacher === "Select Teacher"
            ) {
              processedStudent.teacher = assignedTeacher;
              console.log(
                `Assigned teacher "${assignedTeacher}" to student "${s.name}"`,
              );
            }

            // Debug first few students
            if (resp.students.indexOf(s) < 3) {
              console.log(`Student ${s.name}:`, s);
              console.log(`Processed ${s.name}:`, processedStudent);
              console.log(
                `${s.name} teacher assignment: "${processedStudent.teacher}"`,
              );
            }

            return processedStudent;
          });

          console.log("Final students array:", this.students);
          // Set dateString and periodString
          const now = new Date();
          this.dateString = now.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });
          this.periodString = this.getCurrentPeriod(now);
          this.nextPeriodString = this.getNextPeriod(now);
        },

        formatDate(dt) {
          if (!dt) return "";

          // Check if it's already a formatted time string (like "2:30 PM")
          if (typeof dt === "string" && dt.match(/^\d{1,2}:\d{2} (AM|PM)$/)) {
            return dt; // Already formatted, return as-is
          }

          // Check if it's already a string that's not a valid date
          if (typeof dt === "string" && isNaN(Date.parse(dt))) {
            return dt; // Return as-is if it's not a valid date string
          }

          const d = new Date(dt);
          if (isNaN(d.getTime())) {
            return dt; // Return original value if invalid date
          }

          // Format to 12-hour time with AM/PM (matching backend format)
          let hours = d.getHours();
          const minutes = d.getMinutes().toString().padStart(2, "0");
          const ampm = hours >= 12 ? "PM" : "AM";

          // Convert to 12-hour format
          hours = hours % 12;
          hours = hours ? hours : 12; // 0 should be 12

          return `${hours}:${minutes} ${ampm}`;
        },

        // Format time for display in the UI
        formatTime(timeStr) {
          if (!timeStr) return "";

          // If it's already in "H:MM AM/PM" format, return as-is
          if (
            typeof timeStr === "string" &&
            timeStr.match(/^\d{1,2}:\d{2} (AM|PM)$/)
          ) {
            return timeStr;
          }

          // If it's a hold notice or other text, return as-is
          if (typeof timeStr === "string" && isNaN(Date.parse(timeStr))) {
            return timeStr;
          }

          // Try to parse and format as time
          try {
            const d = new Date(timeStr);
            if (isNaN(d.getTime())) {
              return timeStr; // Return original if invalid
            }

            // Format to 12-hour time with AM/PM
            let hours = d.getHours();
            const minutes = d.getMinutes().toString().padStart(2, "0");
            const ampm = hours >= 12 ? "PM" : "AM";

            hours = hours % 12;
            hours = hours ? hours : 12;

            return `${hours}:${minutes} ${ampm}`;
          } catch (error) {
            return timeStr; // Return original on error
          }
        },

        isReadyToMarkOut(stu) {
          // Student is ready if they have a hold notice (requested) and are first in queue
          if (!stu.holdNotice || stu.outTime) {
            return false; // Not requested or already out
          }

          // Get all students of the same gender
          const studentsOfSameGender = this.students.filter(
            (s) => s.gender === stu.gender,
          );

          // Get all waiting students (have hold notice but no out time)
          const waitingStudents = studentsOfSameGender.filter(
            (s) => s.holdNotice && !s.outTime
          );

          if (waitingStudents.length === 0) {
            return false; // No one waiting
          }

          // Sort waiting students by their position in the queue
          waitingStudents.sort((a, b) => {
            const getPosition = (student) => {
              const match = student.holdNotice.match(/Position (\d+)/);
              return match ? parseInt(match[1]) : 999;
            };
            return getPosition(a) - getPosition(b);
          });

          // Check if this student is first in the queue
          const isFirstInQueue = waitingStudents[0].name === stu.name;

          if (!isFirstInQueue) {
            return false; // Not first in queue
          }

          // Student is first in queue - they're ready if no one of their gender is currently out
          const anyoneOut = studentsOfSameGender.some(
            (s) => s.outTime && !s.backTime,
          );

          return !anyoneOut; // Ready if restroom is available
        },

        // Check if a student should be automatically removed based on time periods
        shouldAutoRemoveStudent(stu) {
          // Only remove students who have completed their trip (both out and back times)
          if (!stu.outTime || !stu.backTime) {
            return false;
          }

          const now = new Date();
          const currentHour = now.getHours();

          // Parse the out time to determine if it was AM or PM usage
          const outTimeStr = stu.outTime.toString().toLowerCase();
          const isAfternoonUsage = outTimeStr.includes('pm');
          const isMorningUsage = outTimeStr.includes('am');

          // Debug logging for this student
          console.log(`Checking auto-removal for ${stu.name}:`);
          console.log(`  - Out time: ${stu.outTime} (AM: ${isMorningUsage}, PM: ${isAfternoonUsage})`);
          console.log(`  - Back time: ${stu.backTime}`);
          console.log(`  - Current hour: ${currentHour}`);

          // If we can't determine the period from the time string, don't auto-remove
          if (!isAfternoonUsage && !isMorningUsage) {
            console.log(`  - Cannot determine AM/PM, keeping student`);
            return false;
          }

          // Remove AM users at noon or later (12:00 PM and beyond)
          if (isMorningUsage && currentHour >= 12) {
            console.log(`  - Auto-removing ${stu.name} - used restroom in AM, now past noon (${currentHour}:xx)`);
            return true;
          }

          // Remove PM users at midnight or later (but before noon the next day)
          // This handles the day transition properly
          if (isAfternoonUsage) {
            // Get the date when the student went out
            const outDate = this.parseOutTimeToDate(stu.outTime);
            if (outDate) {
              const currentDate = new Date();

              // If it's a different day and we're past midnight, remove them
              if (currentDate.getDate() !== outDate.getDate() ||
                currentDate.getMonth() !== outDate.getMonth() ||
                currentDate.getFullYear() !== outDate.getFullYear()) {
                console.log(`  - Auto-removing ${stu.name} - used restroom in PM yesterday, now past midnight`);
                return true;
              }
            }
          }

          console.log(`  - Keeping student (not time to auto-remove yet)`);
          return false;
        },

        // Helper function to parse out time and get the date it occurred
        parseOutTimeToDate(outTimeStr) {
          try {
            // For now, assume the out time is from today
            // In a more robust implementation, you might store the full date/time
            const today = new Date();
            return today;
          } catch (error) {
            console.error("Error parsing out time date:", error);
            return null;
          }
        },

        // Automatically remove students who should no longer be on the table
        autoRemoveExpiredStudents() {
          const studentsToRemove = [];

          this.students.forEach((student, index) => {
            if (this.shouldAutoRemoveStudent(student)) {
              studentsToRemove.push({ student, index });
            }
          });

          // Remove students in reverse order to maintain correct indices
          studentsToRemove.reverse().forEach(({ student, index }) => {
            console.log(`Auto-removing expired student: ${student.name}`);
            this.students.splice(index, 1);
          });

          if (studentsToRemove.length > 0) {
            console.log(`Auto-removed ${studentsToRemove.length} expired students`);

            // Show a brief notification when students are auto-removed
            this.showSuccessMessage(`Auto-removed ${studentsToRemove.length} student${studentsToRemove.length > 1 ? 's' : ''} who completed their restroom visits.`);
          }

          return studentsToRemove.length;
        },

        // Sort students by status: active students first, completed students last
        sortStudentsByStatus() {
          this.students.sort((a, b) => {
            // Determine status for student a
            const aCompleted = a.outTime && a.backTime;
            const aNewlyAdded = !a.outTime && !a.backTime && !a.holdNotice; // Newly added student
            const aActive = !aCompleted && (a.outTime || a.holdNotice || aNewlyAdded);

            // Determine status for student b
            const bCompleted = b.outTime && b.backTime;
            const bNewlyAdded = !b.outTime && !b.backTime && !b.holdNotice; // Newly added student
            const bActive = !bCompleted && (b.outTime || b.holdNotice || bNewlyAdded);

            // Sort order: active students first, then completed students
            if (aActive && bCompleted) return -1; // a (active/new) comes before b (completed)
            if (aCompleted && bActive) return 1;  // b (active/new) comes before a (completed)

            // Within active students, prioritize by status:
            // 1. Currently out (has outTime, no backTime)
            // 2. Waiting (has holdNotice)
            // 3. Newly added (no outTime, no holdNotice, no backTime)
            if (aActive && bActive) {
              const aCurrentlyOut = a.outTime && !a.backTime;
              const bCurrentlyOut = b.outTime && !b.backTime;
              const aWaiting = a.holdNotice && !a.outTime;
              const bWaiting = b.holdNotice && !b.outTime;

              // Currently out students first
              if (aCurrentlyOut && !bCurrentlyOut) return -1;
              if (!aCurrentlyOut && bCurrentlyOut) return 1;

              // Then waiting students
              if (aWaiting && bNewlyAdded) return -1;
              if (bWaiting && aNewlyAdded) return 1;
            }

            // If both have same status, sort alphabetically by name
            return a.name.localeCompare(b.name);
          });

          console.log(`Sorted ${this.students.length} students: active first, completed last`);
        },

        // Auto-assign new student to queue if needed to prevent line cutting
        autoAssignToQueue(newStudent) {
          // Don't auto-assign if student already has a hold notice
          if (newStudent.holdNotice) return;

          // Don't auto-assign if no gender selected yet
          if (!newStudent.gender) return;

          // Check if there are already waiting students of the same gender
          const studentsOfSameGender = this.students.filter(
            (s) => s.gender === newStudent.gender && s.name !== newStudent.name
          );

          const waitingStudents = studentsOfSameGender.filter(
            (s) => s.holdNotice && !s.outTime
          );

          const anyoneOut = studentsOfSameGender.some(
            (s) => s.outTime && !s.backTime
          );

          // If there are waiting students OR someone is currently out, add new student to end of queue
          if (waitingStudents.length > 0 || anyoneOut) {
            const nextPosition = waitingStudents.length + 1;
            newStudent.holdNotice = `Waiting in line. Position ${nextPosition}.`;
            console.log(`Auto-assigned ${newStudent.name} to queue position ${nextPosition} to prevent line cutting`);
          }
        },

        // Helper function to get queue position from hold notice
        getQueuePosition(stu) {
          if (!stu.holdNotice) return null;
          const match = stu.holdNotice.match(/Position (\d+)/);
          return match ? parseInt(match[1]) : null;
        },

        getButtonText(stu) {
          // If student already completed their trip (has both out and back times)
          if (stu.outTime && stu.backTime) {
            return "ALREADY WENT";
          }

          // Check if student has usage limit flag (set by server-side check)
          if (stu.usageLimitReached) {
            return "ALREADY WENT";
          }

          // If student is currently out (has out time but no back time)
          if (stu.outTime && !stu.backTime) {
            return "CURRENTLY OUT";
          }

          // If student has a hold notice but no out time, they are waiting
          if (stu.holdNotice && !stu.outTime) {
            // Check if they're ready to be promoted (restroom available)
            if (this.isReadyToMarkOut(stu)) {
              return "RR AVAILABLE";
            } else {
              const position = this.getQueuePosition(stu);
              return position ? `WAITING (#${position})` : "WAITING";
            }
          }

          // If student has no hold notice and no out time, check queue status
          if (!stu.holdNotice && !stu.outTime) {
            // Check if anyone of the same gender is currently out or waiting
            const studentsOfSameGender = this.students.filter(
              (s) => s.gender === stu.gender,
            );
            const anyoneOut = studentsOfSameGender.some(
              (s) => s.outTime && !s.backTime,
            );
            const anyoneWaiting = studentsOfSameGender.some(
              (s) => s.holdNotice && !s.outTime,
            );

            // If someone is out OR people are waiting, new student must join queue
            if (anyoneOut || anyoneWaiting) {
              return "ADD TO LIST";
            } else {
              return "REQUEST RR";
            }
          }

          // Fallback case
          return "REQUEST RR";
        },

        getButtonClass(stu) {
          let baseClass = "";

          // Determine base button state
          if (stu.outTime && stu.backTime) {
            baseClass = "already-went";
          } else if (stu.usageLimitReached) {
            baseClass = "already-went";
          } else if (stu.outTime && !stu.backTime) {
            baseClass = "currently-out";
          } else if (this.isReadyToMarkOut(stu)) {
            baseClass = "rr-available";
          } else if (stu.holdNotice && !this.isReadyToMarkOut(stu)) {
            baseClass = "waiting";
          } else if (!stu.outTime && !stu.holdNotice) {
            baseClass = ""; // Default styling
          } else {
            baseClass = "disabled";
          }

          return baseClass;
        },

        getButtonTitle(stu) {
          const buttonText = this.getButtonText(stu);
          let baseTitle = "";

          if (buttonText === "RR AVAILABLE") {
            baseTitle = "NEXT IN LINE - Click to send to restroom";
          } else if (buttonText === "ADD TO LIST") {
            baseTitle = "Click to add student to waiting list";
          } else if (buttonText === "REQUEST RR") {
            baseTitle = "Click to request restroom access";
          } else if (buttonText.startsWith("WAITING")) {
            const position = this.getQueuePosition(stu);
            baseTitle = position ? `Student is #${position} in line` : "Student is waiting in line";
          } else {
            baseTitle = `Student status - outTime: ${stu.outTime} | holdNotice: ${stu.holdNotice} | ready to promote: ${this.isReadyToMarkOut(stu)}`;
          }

          return baseTitle;
        },

        getBackButtonText(stu) {
          if (stu.outTime && stu.backTime) {
            return "ALREADY WENT";
          }
          return "BACK";
        },

        getBackButtonTitle(stu) {
          if (stu.outTime && stu.backTime) {
            return "Student has already completed their restroom visit";
          }
          if (stu.outTime && !stu.backTime) {
            return "Click to mark student as returned from restroom";
          }
          return "Back button hidden - student must be marked out first";
        },

        onGenderChange(stu) {
          // Track user activity and update gender on the server
          this.recordUserAction();
          console.log("Gender changed for", stu.name, "to", stu.gender);
        },

        onTeacherChange(stu) {
          // Track user activity and update teacher on the server
          this.recordUserAction();
          console.log("Teacher changed for", stu.name, "to", stu.teacher);
        },

        markOut(stu) {
          console.log("markOut button clicked for:", stu.name);

          // Prevent action if student already went (has both out and back times) or is currently out
          if (
            (stu.outTime && stu.backTime) ||
            (stu.outTime && !stu.backTime)
          ) {
            console.log(
              "Student already went or is currently out, ignoring click",
            );
            return;
          }

          // Prevent action if student has reached usage limit
          if (stu.usageLimitReached) {
            console.log("Student has reached usage limit, ignoring click");
            return;
          }

          // Prevent action if student is waiting but not ready
          if (stu.holdNotice && !this.isReadyToMarkOut(stu)) {
            console.log("Student is waiting but not ready, ignoring click");
            return;
          }

          // Check if there's already a pending update for this student
          if (this.optimisticUI.hasPendingUpdates(stu.name)) {
            console.log("Student already has pending update, ignoring click");
            return;
          }

          this.recordUserAction(); // Track user activity
          console.log("Full student object:", stu);

          // Validate that gender is selected
          if (!stu.gender || stu.gender.trim() === "") {
            console.log("Gender validation failed - showing alert");
            alert(
              "Please select G or B (Gender) before marking the student out.",
            );
            return;
          }

          // If teacher is not selected, auto-assign the detected teacher
          if (
            !stu.teacher ||
            stu.teacher.trim() === "" ||
            stu.teacher === "Select Teacher"
          ) {
            console.log(
              "Teacher not selected, auto-assigning detected teacher:",
              this.detectedTeacher,
            );
            stu.teacher =
              this.detectedTeacher || this.teachers[0] || "Other Teacher";
          }

          // Validate that teacher is now selected
          if (!stu.teacher || stu.teacher.trim() === "") {
            console.log("Teacher validation failed - showing alert");
            alert("Please select a teacher before marking the student out.");
            return;
          }

          console.log("Validations passed. Applying optimistic update for:", {
            studentName: stu.name,
            action: "out",
            teacherName: stu.teacher,
            gender: stu.gender,
          });

          // Apply optimistic update for immediate feedback
          const updateId =
            this.optimisticUI.updateStudentStatusOptimistically(
              stu,
              "out",
              stu.teacher,
              (optimisticState) => {
                // Update the student object immediately
                const studentIndex = this.students.findIndex(
                  (s) => s.name === stu.name,
                );
                if (studentIndex !== -1) {
                  this.students[studentIndex] = {
                    ...this.students[studentIndex],
                    ...optimisticState,
                  };


                }
              },
            );

          // Track update start time for performance monitoring
          const updateStartTime = Date.now();

          // Send request to server using optimized endpoint
          google.script.run
            .withSuccessHandler((resp) => {
              const updateTime = Date.now() - updateStartTime;
              console.log("Mark out successful:", resp);
              console.log(` Update response time: ${updateTime}ms`);

              // Validate update performance target (1 second)
              if (updateTime <= 1000) {
                console.log(
                  ` Update performance target met: ${updateTime}ms (target: 1000ms)`,
                );
              } else {
                console.warn(
                  ` Update performance target missed: ${updateTime}ms (target: 1000ms)`,
                );
              }

              if (resp && resp.success) {
                // Confirm optimistic update with server response
                this.optimisticUI.confirmServerUpdate(
                  updateId,
                  resp,
                  (serverState) => {
                    console.log(
                      "Mark out confirmed, triggering immediate data sync",
                    );
                    // Trigger immediate background refresh and smart polling check
                    setTimeout(() => {
                      this._fetchStudentDataInBackground();
                      // Also trigger immediate smart polling check for other potential updates
                      if (this.smartPolling && this.smartPolling.isActive) {
                        this.smartPolling.checkForUpdates();
                      }
                    }, 100); // Small delay to ensure server-side processing is complete
                  },
                );
              } else {
                // Handle server-side failure
                const errorMsg = (resp && resp.error) ? resp.error : "Unknown server error";
                console.error("Server returned failure:", errorMsg);
                console.error("Full response object:", resp);

                this.optimisticUI.revertOnError(
                  updateId,
                  (originalState) => {
                    // Revert the student object
                    const studentIndex = this.students.findIndex(
                      (s) => s.name === stu.name,
                    );
                    if (studentIndex !== -1) {
                      this.students[studentIndex] = {
                        ...this.students[studentIndex],
                        ...originalState,
                      };

                      // Restore to queue if they were originally waiting
                      if (
                        originalState.holdNotice &&
                        !originalState.outTime
                      ) {

                      }
                    }
                  },
                  errorMsg,
                );

                alert(
                  `Error marking student out: ${errorMsg}\n\nThe change has been reverted.`,
                );
              }
            })
            .withFailureHandler((error) => {
              console.error(
                "Optimized endpoint failed for marking out:",
                error,
              );
              console.log("Attempting fallback method...");

              // Try fallback method before reverting
              this._fallbackUpdateStatus(
                stu.name,
                "out",
                stu.teacher,
                stu.gender,
                updateId,
              );
            })
            .api_updateStatus(
              stu.name,
              "out",
              stu.teacher,
              stu.gender,
            );
        },

        markBack(stu) {
          console.log("markBack button clicked for:", stu.name);

          // Check if there's already a pending update for this student
          if (this.optimisticUI.hasPendingUpdates(stu.name)) {
            console.log("Student already has pending update, ignoring click");
            return;
          }

          this.recordUserAction(); // Track user activity
          console.log("Student data:", stu);
          console.log("Applying optimistic update for back action:", {
            name: stu.name,
            action: "back",
            teacher: stu.teacher,
            gender: stu.gender,
          });

          // Apply optimistic update for immediate feedback
          const updateId =
            this.optimisticUI.updateStudentStatusOptimistically(
              stu,
              "back",
              stu.teacher,
              (optimisticState) => {
                // Update the student object immediately
                const studentIndex = this.students.findIndex(
                  (s) => s.name === stu.name,
                );
                if (studentIndex !== -1) {
                  this.students[studentIndex] = {
                    ...this.students[studentIndex],
                    ...optimisticState,
                  };
                }
              },
            );

          // Track update start time for performance monitoring
          const updateStartTime = Date.now();

          // Send request to server using optimized endpoint
          google.script.run
            .withSuccessHandler((resp) => {
              const updateTime = Date.now() - updateStartTime;
              console.log("Mark back successful:", resp);
              console.log(` Update response time: ${updateTime}ms`);

              // Validate update performance target (1 second)
              if (updateTime <= 1000) {
                console.log(
                  ` Update performance target met: ${updateTime}ms (target: 1000ms)`,
                );
              } else {
                console.warn(
                  ` Update performance target missed: ${updateTime}ms (target: 1000ms)`,
                );
              }

              if (resp && resp.success) {
                // Confirm optimistic update with server response
                this.optimisticUI.confirmServerUpdate(
                  updateId,
                  resp,
                  (serverState) => {
                    console.log(
                      "Mark back confirmed, triggering immediate data sync",
                    );
                    // Trigger immediate background refresh and smart polling check
                    setTimeout(() => {
                      this._fetchStudentDataInBackground();
                      // Also trigger immediate smart polling check for other potential updates
                      if (this.smartPolling && this.smartPolling.isActive) {
                        this.smartPolling.checkForUpdates();
                      }
                    }, 100); // Small delay to ensure server-side processing is complete
                  },
                );
              } else {
                // Handle server-side failure
                const errorMsg = (resp && resp.error) ? resp.error : "Unknown server error";
                console.error("Server returned failure:", errorMsg);
                console.error("Full response object:", resp);

                this.optimisticUI.revertOnError(
                  updateId,
                  (originalState) => {
                    // Revert the student object
                    const studentIndex = this.students.findIndex(
                      (s) => s.name === stu.name,
                    );
                    if (studentIndex !== -1) {
                      this.students[studentIndex] = {
                        ...this.students[studentIndex],
                        ...originalState,
                      };
                    }
                  },
                  errorMsg,
                );

                alert(
                  `Error marking student back: ${errorMsg}\n\nThe change has been reverted.`,
                );
              }
            })
            .withFailureHandler((error) => {
              console.error(
                "Optimized endpoint failed for marking back:",
                error,
              );
              console.log("Attempting fallback method...");

              // Try fallback method before reverting
              this._fallbackUpdateStatus(
                stu.name,
                "back",
                stu.teacher,
                stu.gender,
                updateId,
              );
            })
            .api_updateStatus(
              stu.name,
              "back",
              stu.teacher,
              stu.gender,
            );
        },

        // ===== SEARCH FUNCTIONALITY =====

        /**
         * Load all students for dropdown (called on focus)
         */
        showAllStudents() {
          // If we haven't loaded students yet, load them
          if (!this.studentsLoaded) {
            this.loadAllStudents();
          } else {
            // Show all students if no search term
            if (!this.searchTerm || this.searchTerm.trim() === '') {
              this.searchResults = [...this.allStudents];
            } else {
              this.filterStudents();
            }
            this.showSearchResults = true;
            this.highlightedIndex = -1;
          }
        },

        /**
         * Load all students from the server
         */
        loadAllStudents() {
          this.isSearching = true;

          google.script.run
            .withSuccessHandler((response) => {
              this.isSearching = false;

              if (response && response.success) {
                this.allStudents = response.students || [];
                this.studentsLoaded = true;
                this.searchResults = [...this.allStudents];
                this.showSearchResults = true;
                console.log(`Loaded ${this.allStudents.length} students for dropdown`);
              } else {
                console.error('Failed to load students:', response?.error);
                this.searchResults = [];
                this.showSearchResults = false;
              }
            })
            .withFailureHandler((error) => {
              this.isSearching = false;
              console.error('API call failed to load students:', error);
              this.searchResults = [];
              this.showSearchResults = false;
            })
            .api_getAllStudents();
        },

        /**
         * Filter students based on search term (client-side filtering)
         */
        filterStudents() {
          if (!this.studentsLoaded) {
            this.showAllStudents();
            return;
          }

          const searchTerm = this.searchTerm.trim().toLowerCase();

          if (!searchTerm) {
            // Show all students if no search term
            this.searchResults = [...this.allStudents];
          } else {
            // Filter students client-side
            this.searchResults = this.allStudents.filter(student => {
              const fullName = student.name.toLowerCase();
              const nameParts = fullName.split(' ');

              // Check if search term matches:
              // 1. Start of full name
              // 2. Start of first name  
              // 3. Start of last name
              // 4. Anywhere in full name (for partial matches)
              return fullName.startsWith(searchTerm) ||
                nameParts.some(part => part.startsWith(searchTerm)) ||
                fullName.includes(searchTerm);
            });

            // Sort results by relevance (exact matches first, then partial)
            this.searchResults.sort((a, b) => {
              const aName = a.name.toLowerCase();
              const bName = b.name.toLowerCase();

              // Exact start matches first
              const aStartsWithSearch = aName.startsWith(searchTerm);
              const bStartsWithSearch = bName.startsWith(searchTerm);

              if (aStartsWithSearch && !bStartsWithSearch) return -1;
              if (!aStartsWithSearch && bStartsWithSearch) return 1;

              // Then alphabetical
              return aName.localeCompare(bName);
            });
          }

          this.showSearchResults = true;
          this.highlightedIndex = -1; // Reset highlight when filtering
          console.log(`Filtered to ${this.searchResults.length} students`);
        },

        /**
         * Select a student from search results
         */
        selectStudent(student) {
          console.log('Selected student:', student);

          // Hide search results and clear search
          this.showSearchResults = false;
          this.searchTerm = "";
          this.searchResults = [];

          // Check if student is already in active list
          const existingStudent = this.students.find(s => s.name === student.name);
          if (existingStudent) {
            alert(`${student.name} is already in the active management list.`);
            return;
          }

          // Debug: Check if Google Apps Script is available
          if (!google || !google.script || !google.script.run) {
            console.error('Google Apps Script not available!');
            alert('Error: Google Apps Script not available. Please refresh the page.');
            return;
          }

          console.log('Starting usage limit check for:', student.name);

          // Show loading state while checking usage limit
          this.isLoading = true;
          this.loadingMessage = `Checking restroom usage for ${student.name}...`;

          // Check if student has already used restroom in current period
          google.script.run
            .withSuccessHandler((result) => {
              console.log('Usage limit check result:', result);
              this.isLoading = false;
              this.loadingMessage = "";

              if (!result || !result.success) {
                console.error('Error checking usage limit:', result ? result.error : 'No result returned');
                // Log error but don't show popup - the system should still work
                console.warn('Usage limit check failed, but continuing...');
                // Allow the student to be added if there's an error (failsafe behavior)
              }

              // Debug: Show detailed usage information
              const debugInfo = `
Usage Check for ${student.name}:
 Current Period: ${result.currentPeriod}
 Can Use Restroom: ${result.canUseRestroom}
 Morning Usage: ${result.usageCount?.morning || 0}
 Afternoon Usage: ${result.usageCount?.afternoon || 0}
 Currently Out: ${result.currentlyOut}
 Reason: ${result.reason || 'None'}
              `.trim();
              console.log(debugInfo);

              if (!result.canUseRestroom) {
                // Student has already used restroom - show message instead of adding
                const period = result.currentPeriod || 'today';
                const message = `${student.name} has already used the restroom once in the ${period}.`;

                console.log('Student cannot use restroom:', result.reason);
                // Only show the nice amber notification, no popup alert
                this.showAlreadyWentMessage(student.name, message, result.usageCount);
                return;
              }

              // Student can use restroom - add to active list
              console.log('Student can use restroom, adding to active list');
              const newStudent = {
                name: student.name,
                id: student.id,
                nameId: student.name,
                gender: "",
                teacher: this.detectedTeacher || "",
                outTime: "",
                backTime: "",
                holdNotice: ""
              };

              // Auto-assign to queue if there are already waiting students
              // This prevents new students from cutting in line
              this.autoAssignToQueue(newStudent);

              this.students.push(newStudent);
              console.log(`Added ${student.name} to active management`);

              // Sort students to maintain proper order
              this.sortStudentsByStatus();

              // Scroll to the table so user can see the new student
              setTimeout(() => {
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                  tableContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
              }, 100);
            })
            .withFailureHandler((error) => {
              console.error('Google Apps Script call failed:', error);
              this.isLoading = false;
              this.loadingMessage = "";
              // Log error but don't show popup - continue with adding student as failsafe
              console.warn('Usage limit check failed, adding student anyway as failsafe');

              // Add student anyway if the check fails (failsafe behavior)
              const newStudent = {
                name: student.name,
                id: student.id,
                nameId: student.name,
                gender: "",
                teacher: this.detectedTeacher || "",
                outTime: "",
                backTime: "",
                holdNotice: ""
              };

              this.students.push(newStudent);
              console.log(`Added ${student.name} to active management (failsafe mode)`);

              // Sort students to maintain proper order
              this.sortStudentsByStatus();
            })
            .api_checkStudentUsageLimit(student.name);
        },

        /**
         * Test function to manually check usage limit (for debugging)
         */
        testUsageLimit(studentName) {
          console.log('Testing usage limit for:', studentName);

          google.script.run
            .withSuccessHandler((result) => {
              console.log('Test usage limit result:', result);
              alert(`Usage check result: ${JSON.stringify(result, null, 2)}`);
            })
            .withFailureHandler((error) => {
              console.error('Test usage limit error:', error);
              alert(`Error: ${error.message || error}`);
            })
            .api_checkStudentUsageLimit(studentName);
        },

        /**
         * Debug function to check student selection process
         */
        debugStudentSelection(studentName) {
          console.log('Debugging student selection for:', studentName);

          google.script.run
            .withSuccessHandler((result) => {
              console.log('Debug student selection result:', result);
              alert(`Debug result: ${JSON.stringify(result, null, 2)}`);
            })
            .withFailureHandler((error) => {
              console.error('Debug student selection error:', error);
              alert(`Error: ${error.message || error}`);
            })
            .api_debugStudentSelection(studentName);
        },

        /**
         * Show "Already Went" message with usage details
         */
        showAlreadyWentMessage(studentName, message, usageCount) {
          const alreadyWentMessage = document.createElement('div');

          let detailText = '';
          if (usageCount) {
            const morning = usageCount.morning || 0;
            const afternoon = usageCount.afternoon || 0;
            detailText = `\nUsage today: Morning (${morning}), Afternoon (${afternoon})`;
          }

          alreadyWentMessage.innerHTML = `
            <div style="font-weight: 600; margin-bottom: 4px;"> ${studentName}</div>
            <div style="font-size: 14px;">${message}${detailText}</div>
          `;

          alreadyWentMessage.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff9800;
            color: white;
            padding: 16px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10000;
            max-width: 300px;
            line-height: 1.4;
          `;

          document.body.appendChild(alreadyWentMessage);

          setTimeout(() => {
            alreadyWentMessage.remove();
          }, 5000); // Show for 5 seconds since it has more info
        },

        /**
         * Show success message
         */
        showSuccessMessage(message) {
          const successMessage = document.createElement('div');
          successMessage.textContent = message;
          successMessage.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10000;
            font-weight: 500;
          `;
          document.body.appendChild(successMessage);

          setTimeout(() => {
            successMessage.remove();
          }, 3000);
          setTimeout(() => {
            const table = document.querySelector('.table-container');
            if (table) {
              table.scrollIntoView({ behavior: 'smooth' });
            }
          }, 100);
        },

        /**
         * Get remove button styling based on student status
         */
        getRemoveButtonStyle(stu) {
          if (stu.outTime && stu.backTime) {
            // Student has already went - show as info button (non-clickable)
            return "background-color: #2196f3; color: white; padding: 4px 8px; font-size: 12px; cursor: default;";
          } else {
            // Regular remove button
            return "background-color: #f44336; color: white; padding: 4px 8px; font-size: 12px; cursor: pointer;";
          }
        },

        /**
         * Get remove button icon based on student status
         */
        getRemoveButtonIcon(stu) {
          if (stu.outTime && stu.backTime) {
            return "info"; // Info icon for students who already went
          } else {
            return "close"; // Close icon for active removal
          }
        },

        /**
         * Get remove button title based on student status
         */
        getRemoveButtonTitle(stu) {
          if (stu.outTime && stu.backTime) {
            const outTimeStr = stu.outTime.toString().toLowerCase();
            const isAfternoonUsage = outTimeStr.includes('pm');
            const isMorningUsage = outTimeStr.includes('am');

            if (isMorningUsage) {
              return `${stu.name} already went to the restroom in AM.`;
            } else if (isAfternoonUsage) {
              return `${stu.name} already went to the restroom in PM.`;
            } else {
              return `${stu.name} already had a restroom visit.`;
            }
          } else {
            return "Remove student from active management";
          }
        },



        /**
         * Handle remove button click - only allow removal for active students
         */
        handleRemoveClick(student) {
          // Don't allow manual removal of students who have completed their trip
          if (student.outTime && student.backTime) {
            // Do nothing - completed students can only be removed automatically
            return;
          }

          // Only allow removal of active students (those still using restroom or waiting)
          this.removeStudentAndLog(student);
        },

        /**
         * Remove a student from active management and clear their log entries
         */
        removeStudentAndLog(student) {
          const confirmMessage = `Remove ${student.name} from the restroom list?\n\nThis will also clear their restroom log entries for today.`;

          if (confirm(confirmMessage)) {
            // Remove from UI immediately
            const index = this.students.findIndex(s => s.name === student.name);
            if (index !== -1) {
              this.students.splice(index, 1);
              console.log(`Removed ${student.name} from the restroom list`);
            }

            // Also remove from server Log sheet
            this.removeStudentFromLog(student.name);
          }
        },

        /**
         * Remove a student's log entries from the server Log sheet
         */
        removeStudentFromLog(studentName) {
          console.log(`Removing log entries for ${studentName} from server...`);

          google.script.run
            .withSuccessHandler((response) => {
              console.log(`Log removal response for ${studentName}:`, response);
              if (response && response.success) {
                console.log(`Successfully removed ${studentName} from Log sheet`);
                if (response.entriesRemoved > 0) {
                  this.showSuccessMessage(`Removed ${studentName} and cleared ${response.entriesRemoved} log entries`);
                }
              } else {
                console.warn(`Failed to remove ${studentName} from Log sheet:`, response?.error);
                // Don't show error to user since the UI removal already happened
              }
            })
            .withFailureHandler((error) => {
              console.error(`Error removing ${studentName} from Log sheet:`, error);
              // Don't show error to user since the UI removal already happened
            })
            .api_removeStudentFromLog(studentName);
        },

        /**
         * Remove a student from active management (legacy function for other uses)
         */
        removeStudent(student) {
          const confirmMessage = `Remove ${student.name} from the restroom list?`;

          if (confirm(confirmMessage)) {
            const index = this.students.findIndex(s => s.name === student.name);
            if (index !== -1) {
              this.students.splice(index, 1);
              console.log(`Removed ${student.name} from the restroom list.`);
            }
          }
        },

        /**
         * Hide search results when clicking outside
         */
        hideSearchResults() {
          setTimeout(() => {
            this.showSearchResults = false;
            this.highlightedIndex = -1;
          }, 200); // Small delay to allow click events to fire
        },

        /**
         * Keyboard navigation - highlight next item
         */
        highlightNext() {
          if (this.searchResults.length === 0) return;
          this.highlightedIndex = Math.min(this.highlightedIndex + 1, this.searchResults.length - 1);
        },

        /**
         * Keyboard navigation - highlight previous item
         */
        highlightPrevious() {
          if (this.searchResults.length === 0) return;
          this.highlightedIndex = Math.max(this.highlightedIndex - 1, -1);
        },

        /**
         * Keyboard navigation - select highlighted item
         */
        selectHighlighted() {
          if (this.highlightedIndex >= 0 && this.highlightedIndex < this.searchResults.length) {
            this.selectStudent(this.searchResults[this.highlightedIndex]);
          }
        },

      };
    }
  </script>

  <!-- Alpine.js - loaded after appData function is defined -->
  <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</body>

</html>