<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>NAMS Restroom Sign-Out</title>
    <!-- Import Materialize CSS -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
      rel="stylesheet"
    />
    <!-- Import Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <style>
      .highlight {
        background-color: #ffff99; /* light yellow highlight */
      }
      .hold-text {
        color: red;
      }
      .out-btn {
        background-color: #f9a825; /* amber/dark yellow */
        color: white;
      }
      .out-btn.disabled {
        background-color: #9e9e9e !important; /* grey when disabled */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.6;
      }
      .back-btn {
        background-color: #43a047; /* green */
        color: white;
      }
      .back-btn.active {
        background-color: #d32f2f !important; /* red when student is out and needs to come back */
        color: white !important;
      }
      .back-btn.disabled {
        background-color: #9e9e9e !important; /* grey when disabled */
        color: #ffffff !important;
        pointer-events: none;
        opacity: 0.6;
      }
      .table-container {
        overflow-x: auto;
      }
      
      /* Loading state styles */
      .loading-blur {
        filter: blur(1px);
        opacity: 0.5;
        pointer-events: none;
      }
      
      .loading-overlay {
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container" x-data="appData()" x-init="init()">
      <h5 x-text="dateString"></h5>
      <h6 x-text="'Period: ' + periodString"></h6>
      <small x-text="nextPeriodString" style="color: #666; font-style: italic; display: block; margin-bottom: 10px;"></small>
      
      <!-- Auto-detected teacher info -->
      <div class="row" x-show="detectedTeacher">
        <div class="col s12">
          <div class="card-panel teal lighten-4" style="padding: 10px;">
            <span class="black-text">
              <i class="material-icons tiny" style="vertical-align: text-bottom;">person</i>
              Hello, <strong x-text="detectedTeacher"></strong>
              <small x-show="userEmail">(logged in as: <span x-text="userEmail"></span>)</small>
            </span>
          </div>
        </div>
      </div>
      




      <!-- Test buttons for debugging -->
      <div class="row" style="margin-bottom: 10px;">
        <div class="col s12">
        <!-- Test buttons removed - app is now working -->
        </div>
      </div>

      <!-- Main table with loading overlay -->
      <div class="table-container" style="position: relative;">
        
        <!-- Loading Spinner Overlay -->
        <div x-show="isLoading" 
             class="loading-overlay" 
             style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; 
                    background: rgba(255,255,255,0.8); display: flex; 
                    align-items: center; justify-content: center; 
                    flex-direction: column; z-index: 10; min-height: 200px;">
          <div class="preloader-wrapper small active">
            <div class="spinner-layer spinner-green-only">
              <div class="circle-clipper left">
                <div class="circle"></div>
              </div>
              <div class="gap-patch">
                <div class="circle"></div>
              </div>
              <div class="circle-clipper right">
                <div class="circle"></div>
              </div>
            </div>
          </div>
          <p style="margin-top: 15px; color: #666; font-weight: 500;">
            <span x-text="loadingMessage || 'Loading student data...'"></span>
          </p>
        </div>

        <table class="striped" :class="{ 'loading-blur': isLoading }">
          <thead>
            <tr>
              <th>Student Name</th>
              <th>Gender</th>
              <th>Teacher</th>
              <th>Request</th>
              <th>Out Time</th>
              <th>Back</th>
              <th>Back Time</th>
            </tr>
          </thead>
          <tbody>
            <template x-for="stu in students" :key="stu.name">
              <tr :class="{ highlight: isNextInQueue(stu) }">
                <td x-text="stu.name"></td>
                <td>
                  <select x-model="stu.gender" @change="onGenderChange(stu)" class="browser-default">
                    <option value=""></option>
                    <option value="G">G</option>
                    <option value="B">B</option>
                  </select>
                </td>
                <td>
                  <select x-model="stu.teacher" @change="onTeacherChange(stu)" class="browser-default">
                    <option value="">Select Teacher</option>
                    <template x-for="t in teachers" :key="t">
                      <option x-text="t" :value="t"></option>
                    </template>
                  </select>
                </td>
                <td>
                  <button
                    class="btn out-btn"
                    :class="{ 'disabled': stu.outTime || stu.holdNotice }"
                    @click="markOut(stu)"
                    :title="'Out disabled: ' + (stu.outTime || stu.holdNotice ? 'true' : 'false') + ' | outTime: ' + stu.outTime + ' | holdNotice: ' + stu.holdNotice"
                  >
                    Out
                  </button>
                </td>
                <td>
                  <span x-text="formatTime(stu.outTime || stu.holdNotice)"></span>
                </td>
                <td>
                  <button
                    class="btn back-btn"
                    :class="{ 
                      'disabled': !stu.outTime || stu.backTime,
                      'active': stu.outTime && !stu.backTime
                    }"
                    @click="markBack(stu)"
                    :title="'Back disabled: ' + (!stu.outTime || stu.backTime ? 'true' : 'false') + ' | outTime: ' + stu.outTime + ' | backTime: ' + stu.backTime"
                  >
                    Back
                  </button>
                </td>
                <td>
                  <span x-text="formatTime(stu.backTime)"></span>
                </td>
              </tr>
            </template>
          </tbody>
        </table>
      </div>

      <br />

      <!-- Queue table -->
      <h5>Waiting List</h5>
      <table class="striped">
        <thead>
          <tr>
            <th>Girls</th>
            <th>Boys</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <template x-for="(g, idx) in queue.girls" :key="g">
                <div :class="{ highlight: idx === 0 }" x-text="g"></div>
              </template>
            </td>
            <td>
              <template x-for="(b, idx) in queue.boys" :key="b">
                <div :class="{ highlight: idx === 0 }" x-text="b"></div>
              </template>
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Materialize JS (for any components) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <script>
      function appData() {
        return {
          dateString: "",
          periodString: "",
          nextPeriodString: "",
          teachers: [],
          detectedTeacher: "",
          userEmail: "",
          students: [],
          queue: { girls: [], boys: [] },
          isLoading: false,
          loadingMessage: "",
          lastActionTime: 0,
          lastUpdateTimestamp: 0,
          refreshInterval: null,

          init() {
            this.loadUserInfo();
            // Update period every minute
            setInterval(() => {
              const now = new Date();
              this.periodString = this.getCurrentPeriod(now);
              this.nextPeriodString = this.getNextPeriod(now);
            }, 60000);
          },

          // Bell Schedule Configuration
          // Unified NAMS Bell Schedule 2025-2026 (combining 4th & 5th periods)
          getBellSchedule() {
            return [
              { period: '1st', start: '8:40', end: '9:26' },
              { period: '2nd', start: '9:30', end: '10:16' },
              { period: '3rd', start: '10:20', end: '11:06' },
              { period: '4th & 5th', start: '11:10', end: '1:21' },
              { period: '6th', start: '1:25', end: '2:11' },
              { period: '7th', start: '2:15', end: '3:01' },
              { period: '8th', start: '3:05', end: '3:55' }
            ];
          },

          // Convert time string (e.g., "8:40", "1:21") to minutes since midnight
          // Assumes times after 1:00 and before 8:00 are PM
          timeToMinutes(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            let adjustedHours = hours;
            
            // Convert to 24-hour format
            // Times from 1:00 to 7:59 are assumed to be PM (afternoon/evening)
            if (hours >= 1 && hours <= 7) {
              adjustedHours = hours + 12;
            }
            
            const result = adjustedHours * 60 + minutes;
            console.log(`timeToMinutes("${timeStr}") = ${adjustedHours}*60 + ${minutes} = ${result} (original hours: ${hours})`);
            return result;
          },

          // Get the current period based on time
          getCurrentPeriod(now = new Date()) {
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
            
            // Debug logging
            console.log('Current time debug:', {
              fullDate: now.toString(),
              hours: now.getHours(),
              minutes: now.getMinutes(),
              currentTimeInMinutes: currentTime,
              dayOfWeek: dayOfWeek,
              timeString: now.toLocaleTimeString()
            });
            
            // School only operates Monday-Friday
            if (dayOfWeek === 0 || dayOfWeek === 6) {
              return 'Weekend - No School';
            }

            // Before school starts (8:40 = 520 minutes)
            const schoolStartMinutes = this.timeToMinutes('8:40');
            console.log('School start check:', currentTime, '<', schoolStartMinutes, '=', currentTime < schoolStartMinutes);
            if (currentTime < schoolStartMinutes) {
              return 'Before School';
            }

            // After school ends (3:55 = 955 minutes)
            const schoolEndMinutes = this.timeToMinutes('3:55');
            console.log('School end check:', currentTime, '>', schoolEndMinutes, '=', currentTime > schoolEndMinutes);
            if (currentTime > schoolEndMinutes) {
              return 'After School';
            }

            // Get the unified schedule
            const periods = this.getBellSchedule();

            // Check each period
            for (const period of periods) {
              const startTime = this.timeToMinutes(period.start);
              const endTime = this.timeToMinutes(period.end);
              
              console.log(`Checking ${period.period}:`, currentTime, 'between', startTime, 'and', endTime);
              
              if (currentTime >= startTime && currentTime <= endTime) {
                return `${period.period} (${period.start} - ${period.end})`;
              }
            }

            // Check for passing periods (between classes)
            for (let i = 0; i < periods.length - 1; i++) {
              const currentPeriodEnd = this.timeToMinutes(periods[i].end);
              const nextPeriodStart = this.timeToMinutes(periods[i + 1].start);
              
              if (currentTime > currentPeriodEnd && currentTime < nextPeriodStart) {
                return `Passing Period (${periods[i].period} → ${periods[i + 1].period})`;
              }
            }

            return `Current Time: ${now.toLocaleTimeString()} (${currentTime} minutes)`;
          },

          // Get information about the next period
          getNextPeriod(now = new Date()) {
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const dayOfWeek = now.getDay();
            
            // School only operates Monday-Friday
            if (dayOfWeek === 0 || dayOfWeek === 6) {
              return 'No upcoming periods - Weekend';
            }

            // After school ends
            if (currentTime > this.timeToMinutes('3:55')) {
              return 'No more periods today';
            }

            const periods = this.getBellSchedule();

            // Find the next period that hasn't started yet
            for (const period of periods) {
              const startTime = this.timeToMinutes(period.start);
              
              if (currentTime < startTime) {
                const minutesUntil = startTime - currentTime;
                const hours = Math.floor(minutesUntil / 60);
                const mins = minutesUntil % 60;
                
                let timeUntil = '';
                if (hours > 0) {
                  timeUntil = `${hours}h ${mins}m`;
                } else {
                  timeUntil = `${mins}m`;
                }
                
                return `Next: ${period.period} in ${timeUntil} (${period.start} - ${period.end})`;
              }
            }

            return 'No more periods today';
          },

          loadUserInfo() {
            console.log('Loading user information...');
            google.script.run
              .withSuccessHandler((userInfo) => {
                console.log('User info received:', userInfo);
                this.userEmail = userInfo.userEmail;
                this.detectedTeacher = userInfo.detectedTeacher;
                this.teachers = userInfo.teacherList;
                
                // Initialize date and period
                const now = new Date();
                this.dateString = now.toLocaleDateString('en-US', { 
                  weekday: 'long', 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric' 
                });
                this.periodString = this.getCurrentPeriod(now);
                this.nextPeriodString = this.getNextPeriod(now);
                
                // Now load the student data
                this.refreshData();
                // Start smart refresh system instead of constant polling
                this.startSmartRefresh();
              })
              .withFailureHandler((error) => {
                console.error('Error loading user info:', error);
                // Use fallback teacher list
                this.teachers = [
                  "Mr. Aguilar", "Mrs. Atoui", "Mrs. Bowery", "Mrs. Cantu", "Mr. Casanova",
                  "Mrs. Coyle", "Mr. De Leon", "Mrs. Farias", "Mr. Franco", "Mr. Garcia",
                  "Mr. Goff", "Mr. Gomez", "Dr. Gonzales", "Mr. Hernandez", "Mrs. Hutton",
                  "Mrs. Idrogo", "Mrs. Jasso", "Mrs. Marquez", "Mr. Ollendieck", "Mr. Paez",
                  "Mr. Ramon", "Mrs. Tellez", "Mr. Trevino", "Mrs. Wine", "Mrs. Yeager",
                  "Other Teacher"
                ];
                this.detectedTeacher = "Other Teacher";
                
                // Initialize date and period
                const now = new Date();
                this.dateString = now.toLocaleDateString('en-US', { 
                  weekday: 'long', 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric' 
                });
                this.periodString = this.getCurrentPeriod(now);
                this.nextPeriodString = this.getNextPeriod(now);
                
                // Load student data even if user info fails
                this.refreshData();
                this.startSmartRefresh();
              })
              .api_getCurrentUserInfo();
          },



          // Ultra simple test with hardcoded data
          testUltraSimple() {
            console.log('Testing ultra simple...');
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('Ultra simple response:', resp);
                if (resp && resp.students) {
                  alert(`Ultra Simple SUCCESS!\nStudents: ${resp.students.length}`);
                  this.handleFetch(resp);
                } else {
                  alert(`Ultra Simple FAILED - received: ${JSON.stringify(resp)}`);
                }
              })
              .withFailureHandler((error) => {
                console.error('Ultra simple failed:', error);
                alert(`Ultra simple failed: ${error.message || error}`);
              })
              .api_ultraSimpleTest();
          },

          // Test roster only (no status processing)
          testRosterOnly() {
            console.log('Testing roster only...');
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('Roster only response:', resp);
                if (resp && resp.students) {
                  alert(`Roster Only SUCCESS!\nStudents: ${resp.students.length}\nFirst: ${resp.students[0] ? resp.students[0].name : 'None'}`);
                  this.handleFetch(resp);
                } else {
                  alert(`Roster Only FAILED - received: ${JSON.stringify(resp)}`);
                }
              })
              .withFailureHandler((error) => {
                console.error('Roster only failed:', error);
                alert(`Roster only failed: ${error.message || error}`);
              })
              .api_testRosterOnly();
          },

          // Test minimal bypass version (no status processing at all)
          testMinimalBypass() {
            console.log('Testing MINIMAL bypass version...');
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('Minimal bypass response:', resp);
                if (resp && resp.students) {
                  alert(`MINIMAL BYPASS SUCCESS!\nStudents: ${resp.students.length}\nFirst student: ${resp.students[0] ? resp.students[0].name : 'None'}\nNo status processing!`);
                  // Load this data into the interface
                  this.students = resp.students;
                  this.queue = resp.queue || { girls: [], boys: [] };
                } else {
                  console.error('Minimal bypass returned invalid structure:', resp);
                  alert('Minimal bypass returned invalid data: ' + JSON.stringify(resp));
                }
              })
              .withFailureHandler((error) => {
                console.error('Minimal bypass failed:', error);
                alert(`Minimal bypass failed: ${error.message || error}`);
              })
              .api_minimalBypass();
          },

          // Test the October 16 version
          testOctober16() {
            console.log('Testing October 16 2025 version...');
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('October 16 response:', resp);
                if (resp && resp.students) {
                  alert(`OCTOBER 16 SUCCESS!\nStudents: ${resp.students.length}\nFirst student: ${resp.students[0] ? resp.students[0].name : 'None'}`);
                  // Load this data into the interface
                  this.students = resp.students;
                  this.queue = resp.queue || { girls: [], boys: [] };
                } else {
                  console.error('October 16 returned invalid structure:', resp);
                  alert('October 16 returned invalid data: ' + JSON.stringify(resp));
                }
              })
              .withFailureHandler((error) => {
                console.error('October 16 failed:', error);
                alert(`October 16 failed: ${error.message || error}`);
              })
              .api_october16_2025();
          },

          // Test the new function
          testNewFunction() {
            console.log('Testing FINAL working version...');
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('Final version response:', resp);
                if (resp && resp.students) {
                  alert(`FINAL VERSION SUCCESS!\nStudents: ${resp.students.length}\nFirst student: ${resp.students[0] ? resp.students[0].name : 'None'}`);
                  // Load this data into the interface
                  this.students = resp.students;
                  this.queue = resp.queue || { girls: [], boys: [] };
                } else {
                  console.error('Final version returned invalid structure:', resp);
                  alert('Final version returned invalid data: ' + JSON.stringify(resp));
                }
              })
              .withFailureHandler((error) => {
                console.error('Final version failed:', error);
                alert(`Final version failed: ${error.message || error}`);
              })
              .api_finalWorkingVersion();
          },

          refreshData() {
            console.log('refreshData() called - trying Script Properties implementation');
            this.isLoading = true;
            this.loadingMessage = "Loading student data...";
            
            // First try the new Script Properties function
            google.script.run
              .withSuccessHandler(data => {
                console.log('✓ Script Properties data loaded successfully:', data);
                if (data && data.students) {
                  this.students = data.students;
                  this.queue = data.queue || { girls: [], boys: [] };
                  this.isLoading = false;
                  this.loadingMessage = "";
                  this.lastUpdateTimestamp = Date.now(); // Record successful refresh
                  console.log('✓ Script Properties data applied successfully');
                } else {
                  console.warn('Script Properties returned null, falling back...');
                  this.loadingMessage = "Trying fallback method...";
                  this.fallbackToMinimalBypass();
                }
              })
              .withFailureHandler(error => {
                console.error('Script Properties failed:', error);
                this.loadingMessage = "Trying fallback method...";
                this.fallbackToMinimalBypass();
              })
              .api_loadWithScriptProperties();
          },

          // Smart refresh system - only refresh when there are actual changes
          startSmartRefresh() {
            console.log('Starting smart refresh system...');
            // Check for updates every 60 seconds instead of constant refreshing
            // This reduces server load while keeping data reasonably fresh
            this.refreshInterval = setInterval(() => {
              // Only refresh if no recent user activity
              const timeSinceLastAction = Date.now() - (this.lastActionTime || 0);
              if (timeSinceLastAction > 45000) { // 45 seconds since last action
                console.log('Smart refresh: Checking for updates...');
                this.checkForUpdates();
              } else {
                console.log('Smart refresh: Skipping check due to recent activity');
              }
            }, 60000); // Check every 60 seconds
          },

          // Check if there are any updates without doing a full refresh
          checkForUpdates() {
            google.script.run
              .withSuccessHandler((updateInfo) => {
                console.log('Update check response:', updateInfo);
                if (updateInfo && updateInfo.hasUpdates) {
                  console.log('Updates detected, refreshing data...');
                  this.lastUpdateTimestamp = updateInfo.timestamp || Date.now();
                  this.refreshData();
                } else {
                  console.log('No updates detected, keeping current data');
                  // Update timestamp even if no changes to avoid redundant checks
                  this.lastUpdateTimestamp = updateInfo?.timestamp || Date.now();
                }
              })
              .withFailureHandler((error) => {
                console.warn('Update check failed:', error);
                // Fallback to regular refresh on error, but less frequently
                if (Date.now() - (this.lastUpdateTimestamp || 0) > 300000) { // 5 minutes
                  console.log('Fallback refresh due to failed update check');
                  this.refreshData();
                }
              })
              .api_hasUpdatesAvailable(this.lastUpdateTimestamp || 0);
          },

          // Track user actions to avoid unnecessary refreshes
          recordUserAction() {
            this.lastActionTime = Date.now();
            console.log('User action recorded');
          },

          fallbackToMinimalBypass() {
            console.log('Using fallback: api_minimalBypass + log data merge');
            
            google.script.run
              .withSuccessHandler((result) => {
                console.log('Fallback roster received:', result);
                
                if (result && result.students) {
                  // Process basic roster first
                  this.students = result.students.map((s) => {
                    const assignedTeacher = this.detectedTeacher || this.teachers[0] || "Other Teacher";
                    
                    return {
                      name: s.name,
                      gender: s.gender || "",
                      teacher: s.teacher || assignedTeacher,
                      outTime: s.outTime ? this.formatDate(s.outTime) : "",
                      backTime: s.backTime ? this.formatDate(s.backTime) : "",
                      holdNotice: s.holdNotice || ""
                    };
                  });
                  
                  this.queue = result.queue || { girls: [], boys: [] };
                  
                  // Now try to merge log data
                  this.mergeLogDataFallback();
                  
                } else {
                  console.error('Even fallback failed:', result);
                  alert('Unable to load student data. Please refresh the page.');
                }
              })
              .withFailureHandler((error) => {
                console.error('Fallback also failed:', error);
                alert('Critical error loading data: ' + error.message);
              })
              .api_minimalBypass();
          },

          mergeLogDataFallback() {
            console.log('Attempting to merge log data in fallback mode');
            
            google.script.run
              .withSuccessHandler((logData) => {
                console.log('Fallback log data received:', logData);
                
                if (logData && logData.todaysEntries && Array.isArray(logData.todaysEntries)) {
                  const logEntries = logData.todaysEntries;
                  console.log(`Merging ${logEntries.length} log entries in fallback mode`);
                  
                  // Merge log data into existing students
                  this.students = this.students.map(student => {
                    const studentLogs = logEntries.filter(log => log.studentName === student.name);
                    
                    if (studentLogs.length > 0) {
                      const latestLog = studentLogs[studentLogs.length - 1];
                      console.log(`Fallback merge for ${student.name}:`, latestLog);
                      
                      return {
                        ...student,
                        gender: latestLog.gender || student.gender,
                        teacher: latestLog.teacher || student.teacher,
                        outTime: latestLog.outTime ? this.formatDate(latestLog.outTime) : student.outTime,
                        backTime: latestLog.backTime ? this.formatDate(latestLog.backTime) : student.backTime,
                        holdNotice: latestLog.holdNotice || student.holdNotice
                      };
                    }
                    
                    return student;
                  });
                  
                  console.log('Fallback log merge completed successfully');
                } else {
                  console.log('No log entries to merge in fallback mode');
                }
                
                // Clear loading state after merge completes
                this.isLoading = false;
                this.loadingMessage = "";
              })
              .withFailureHandler((error) => {
                console.warn('Fallback log merge failed:', error);
                // Continue without log data - don't show error to user since we have basic roster
                this.isLoading = false;
                this.loadingMessage = "";
              })
              .api_debugLogSheet();
          },

          handleFetch(resp) {
            // Check if response is valid
            if (!resp) {
              console.error('Received null response from fetchData');
              alert('Error: No data received from server. Please refresh the page.');
              return;
            }
            
            if (!resp.students || !Array.isArray(resp.students)) {
              console.error('Invalid response structure:', resp);
              alert('Error: Invalid data structure received from server. Please refresh the page.');
              return;
            }
            
            // resp has { students, queue }
            console.log('Processing students:', resp.students);
            console.log('Detected teacher for assignment:', this.detectedTeacher);
            
            this.students = resp.students.map((s) => {
              // Since student data from daily sheet doesn't include teacher,
              // assign all students to the currently logged-in teacher
              const assignedTeacher = this.detectedTeacher || this.teachers[0] || "Other Teacher";
              
              const processedStudent = {
                name: s.name,
                gender: s.gender || "",
                teacher: s.teacher || assignedTeacher,
                outTime: s.outTime ? this.formatDate(s.outTime) : "",
                backTime: s.backTime ? this.formatDate(s.backTime) : "",
                holdNotice: s.holdNotice || ""
              };
              
              // Ensure teacher is always set to detected teacher if not already assigned
              if (!processedStudent.teacher || processedStudent.teacher.trim() === "" || processedStudent.teacher === "Select Teacher") {
                processedStudent.teacher = assignedTeacher;
                console.log(`Assigned teacher "${assignedTeacher}" to student "${s.name}"`);
              }
              
              // Debug first few students
              if (resp.students.indexOf(s) < 3) {
                console.log(`Student ${s.name}:`, s);
                console.log(`Processed ${s.name}:`, processedStudent);
                console.log(`${s.name} teacher assignment: "${processedStudent.teacher}"`);
              }
              
              return processedStudent;
            });
            this.queue = resp.queue;
            console.log('Final students array:', this.students);
            // Set dateString and periodString
            const now = new Date();
            this.dateString = now.toLocaleDateString('en-US', { 
              weekday: 'long', 
              year: 'numeric', 
              month: 'long', 
              day: 'numeric' 
            });
            this.periodString = this.getCurrentPeriod(now);
            this.nextPeriodString = this.getNextPeriod(now);
          },

          formatDate(dt) {
            if (!dt) return "";
            
            // Check if it's already a formatted time string (like "2:30 PM")
            if (typeof dt === 'string' && dt.match(/^\d{1,2}:\d{2} (AM|PM)$/)) {
              return dt; // Already formatted, return as-is
            }
            
            // Check if it's already a string that's not a valid date
            if (typeof dt === 'string' && isNaN(Date.parse(dt))) {
              return dt; // Return as-is if it's not a valid date string
            }
            
            const d = new Date(dt);
            if (isNaN(d.getTime())) {
              return dt; // Return original value if invalid date
            }
            
            // Format to 12-hour time with AM/PM (matching backend format)
            let hours = d.getHours();
            const minutes = d.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            
            // Convert to 12-hour format
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12
            
            return `${hours}:${minutes} ${ampm}`;
          },

          // Format time for display in the UI
          formatTime(timeStr) {
            if (!timeStr) return "";
            
            // If it's already in "H:MM AM/PM" format, return as-is
            if (typeof timeStr === 'string' && timeStr.match(/^\d{1,2}:\d{2} (AM|PM)$/)) {
              return timeStr;
            }
            
            // If it's a hold notice or other text, return as-is
            if (typeof timeStr === 'string' && isNaN(Date.parse(timeStr))) {
              return timeStr;
            }
            
            // Try to parse and format as time
            try {
              const d = new Date(timeStr);
              if (isNaN(d.getTime())) {
                return timeStr; // Return original if invalid
              }
              
              // Format to 12-hour time with AM/PM
              let hours = d.getHours();
              const minutes = d.getMinutes().toString().padStart(2, '0');
              const ampm = hours >= 12 ? 'PM' : 'AM';
              
              hours = hours % 12;
              hours = hours ? hours : 12;
              
              return `${hours}:${minutes} ${ampm}`;
            } catch (error) {
              return timeStr; // Return original on error
            }
          },

          isNextInQueue(stu) {
            const q = this.queue[stu.gender === "G" ? "girls" : "boys"];
            return q.length > 0 && q[0] === stu.name;
          },

          onGenderChange(stu) {
            // Update gender on the server
            console.log('Gender changed for', stu.name, 'to', stu.gender);
          },
          onTeacherChange(stu) {
            // Update teacher on the server
            console.log('Teacher changed for', stu.name, 'to', stu.teacher);
          },



          markOut(stu) {
            console.log('markOut button clicked for:', stu.name);
            this.recordUserAction(); // Track user activity
            console.log('Full student object:', stu);
            console.log('Gender value:', `"${stu.gender}"`, 'Type:', typeof stu.gender, 'Length:', stu.gender ? stu.gender.length : 'N/A');
            console.log('Teacher value:', `"${stu.teacher}"`, 'Type:', typeof stu.teacher, 'Length:', stu.teacher ? stu.teacher.length : 'N/A');
            console.log('Detected teacher:', this.detectedTeacher);
            
            // Validate that gender is selected
            if (!stu.gender || stu.gender.trim() === "") {
              console.log('Gender validation failed - showing alert');
              alert('Please select G or B (Gender) before marking the student out.');
              return;
            }
            
            // If teacher is not selected, auto-assign the detected teacher
            if (!stu.teacher || stu.teacher.trim() === "" || stu.teacher === "Select Teacher") {
              console.log('Teacher not selected, auto-assigning detected teacher:', this.detectedTeacher);
              stu.teacher = this.detectedTeacher || this.teachers[0] || "Other Teacher";
            }
            
            // Validate that teacher is now selected
            if (!stu.teacher || stu.teacher.trim() === "") {
              console.log('Teacher validation failed - showing alert');
              alert('Please select a teacher before marking the student out.');
              return;
            }
            
            console.log('Validations passed. Calling api_updateStatus with:', {
              studentName: stu.name,
              action: "out", 
              teacherName: stu.teacher,
              gender: stu.gender
            });
            
            // Show loading state for this specific operation
            this.isLoading = true;
            this.loadingMessage = `Marking ${stu.name} OUT...`;
            
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('Mark out successful:', resp);
                this.loadingMessage = "Refreshing data...";
                // Always refresh data after successful operation to get latest times from log
                setTimeout(() => {
                  this.refreshData();
                }, 500); // Short delay to ensure server has processed the update
              })
              .withFailureHandler((error) => {
                console.error('Error marking out:', error);
                console.error('Error details:', error.message, error.stack);
                this.isLoading = false;
                this.loadingMessage = "";
                alert(`Error marking student out: ${error.message || error}\n\nCheck console for details.`);
              })
              .api_updateStatus(stu.name, "out", stu.teacher, stu.gender);
          },

          markBack(stu) {
            console.log('markBack button clicked for:', stu.name);
            this.recordUserAction(); // Track user activity
            console.log('Student data:', stu);
            console.log('Calling api_updateStatus with:', {
              name: stu.name,
              action: "back", 
              teacher: stu.teacher,
              gender: stu.gender
            });
            
            // Show loading state for this specific operation
            this.isLoading = true;
            this.loadingMessage = `Marking ${stu.name} BACK...`;
            
            google.script.run
              .withSuccessHandler((resp) => {
                console.log('Mark back successful:', resp);
                this.loadingMessage = "Refreshing data...";
                // Always refresh data after successful operation to get latest times from log
                setTimeout(() => {
                  this.refreshData();
                }, 500); // Short delay to ensure server has processed the update
              })
              .withFailureHandler((error) => {
                console.error('Error marking back:', error);
                this.isLoading = false;
                this.loadingMessage = "";
                alert('Error marking student back. Please try again.');
              })
              .api_updateStatus(stu.name, "back", stu.teacher, stu.gender);
          }
        };
      }
    </script>
    
    <!-- Alpine.js - loaded after appData function is defined -->
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  </body>
</html>
